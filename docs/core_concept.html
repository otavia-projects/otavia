<!DOCTYPE html><html data-pathToRoot="../"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Core Concepts and Design</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/staticsitestyles.css"></link><script>var pathToRoot = "../";</script><meta charset="utf-8"> 
<title>Hello, world!</title></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../home.html" class="logo-container"><span class="project-name h300">otavia</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">0.3.8-SNAPSHOT</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span class="project-name h300">otavia</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="index.html">Docs</a><a id="api-nav-button" class="switcher h100 " href="../index.html">API</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0 "><span class="nh de"><a href="name_from.html"><span>Name From</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="quick_start.html"><span>Quick Start</span></a></span></div><div class="ni n0 expanded"><span class="nh h100 selected de"><a href="#"><span>Core Concepts and Design</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="guide/index.html"><span>Guide</span></a></span><div class="ni n1 "><span class="nh de"><a href="guide/actor_model.html"><span>Actor Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/channel_pipeline.html"><span>Channel Pipeline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/io_model.html"><span>IO Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/ioc.html"><span>Actor IOC </span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/message_model.html"><span>Message Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/reactor_model.html"><span>Reactor Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/slf4a.html"><span>SLF4A</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/serde.html"><span>Serde framework</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="module/index.html"><span>Modules</span></a></span><div class="ni n1 "><span class="nh de"><a href="module/buffer.html"><span>Buffer</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="zh/index.html"><span>中文文档</span></a></span><div class="ni n1 "><span class="nh de"><a href="zh/name_from.html"><span>名称来源</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="zh/quick_start.html"><span>快速开始</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="zh/core_concept.html"><span>核心概念与设计</span></a></span></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="zh/guide/index.html"><span>Guide</span></a></span><div class="ni n2 "><span class="nh de"><a href="zh/guide/channel_pipeline.html"><span>Channel Pipeline</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="zh/guide/io_model.html"><span>IO Model</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="zh/guide/ioc.html"><span>Actor IOC </span></a></span></div><div class="ni n2 "><span class="nh de"><a href="zh/guide/message_model.html"><span>Message Model</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="zh/guide/reactor_model.html"><span>Reactor Model</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="zh/guide/slf4a.html"><span>SLF4A</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="zh/module/index.html"><span>Modules</span></a></span><div class="ni n2 "><span class="nh de"><a href="zh/module/buffer.html"><span>Buffer</span></a></span></div></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="blog/index.html"><span>Blog</span></a></span><div class="ni n1 "><span class="nh de"><a href="blog/2023/05/19/hello-world-blog.zh-cn.html"><span>你好世界</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="blog/2023/05/19/hello-world-blog.html"><span>hello world blog</span></a></span></div></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/otavia-projects/otavia"><button class="icon-button gh"></button></a><div class="text">Copyright (c) 2022, Yan Kun/Otavia Project</div></div><div class="text-mobile">Copyright (c) 2022, Yan Kun/Otavia Project</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="index.html">otavia</a>/<a href="core_concept.html">Core Concepts and Design</a></div><div id="content" class="body-medium"><div><section id="challenges-of-existing-programming-paradigm-1"> 
 <h2 class="h500"><a href="#challenges-of-existing-programming-paradigm-1" class="anchor"></a>Challenges of existing programming paradigm</h2> 
 <p>As Moore's Law fades and the size of modern software systems grows exponentially, single-core CPUs and even standalone computers are no longer enough to meet our needs. In order to meet this challenge, modern software systems not only need to work well with multi-core CPUs on a single machine, but also need to run on multiple computers in a distributed manner. These challenges are seriously impacting the current mainstream programming paradigm and making the current mainstream programming languages evolve in new directions.</p> 
 <p>The first is asynchronous programming, but the combination of the object-oriented programming paradigm and asynchronous programming often produces callback hell. This approach destroys object-oriented encapsulation and also makes the code logic more diffuse, making it less maintainable.</p> 
 <p>The second is that functional programming has become more popular, and now basically all major programming languages support some functional features. Functional programming presents a beautiful vision: everything is immutable! This makes writing code like defining a mathematical function; once the function is defined, every time it is called, as long as the input is the same then the output is the same, and there is no behavior beyond that. This programming paradigm is a wonderful idea, and code written in this way is not only secure but also easier to test and the behavior of the code is more controllable. But functional programming has some drawbacks: it's not easy to deal with state, and a real software system often needs to deal with a lot of state, IO, and so on. Although functional programming also has techniques such as <code>Monad</code> and <code>Effect</code> to deal with these scenarios, these techniques are too complex and expensive for many developers to learn. Remember that famous quote?</p> 
 <blockquote> 
  <p>A monad is just a monoid in the category of endofunctors, what's the problem?</p> 
 </blockquote> 
 <p>Meanwhile, there is an old programming paradigm that seems to be better suited to the complexity of modern, highly concurrent, distributed software systems: the Actor model, proposed in 1973. But the Actor model also has some drawbacks, which is perhaps why it has not become as popular as object-oriented programming.</p> 
 <p><code>otavia</code> is an Actor programming model implemented in <code>Scala 3</code>. We hope to explore a way to integrate the Actor model more effectively with modern programming languages, and also to explore ways to address some of the shortcomings of the traditional Actor model. The following article provides an overview of the core concepts and design of <code>otavia</code>.</p> 
</section> 
<section id="design-principles-of-otavia-1"> 
 <h2 class="h500"><a href="#design-principles-of-otavia-1" class="anchor"></a>Design principles of otavia</h2> 
 <p>Object-oriented programming is a very useful programming paradigm, and while the original object-oriented idea was somewhat similar to the Actor model, where an object is equivalent to an Actor, modern implementations of object-oriented in the major programming languages have degraded it to a way of organizing and encapsulating the code, since the cost of calling methods directly is much less than message passing. This is wonderful in the single-threaded case, where everything is organized.</p> 
 <p>But the crisis came with multithreading and multiple CPU cores: multithreading is like a herd of savage bulls rampaging through a fragile jungle of objects! Instead of having a single path of execution, programs are now controlled by a well-organized set of objects. Instead, you need to care carefully whether each object will be accessed by more than one thread at the same time, and you need to double-check your program's concurrency safety. But it's not easy to do. Especially for a software system of enormous size, you don't know how many threads are rushing through your jungle of objects, so you need to go out and simulate every thread with a human brain, track their paths, and then figure out which objects should need to deal with concurrency safety. Imagine tracking down this herd of savage bulls in the jungle, meticulously checking one by one which grasses they've stepped on! God, it's maddening to think about. All this work was already exhausting, but there was an even more serious problem: these bulls would suddenly come to a standstill when they stepped on certain grass! They are blocked and thus suspended, and this reduces the system's CPU utilization, which in turn may lead to the launching of more threads, with more and more concurrent contention, until the system crashes under a concurrency problem that is not rigorously examined!</p> 
 <p>Happily, new technologies have emerged to solve these problems. The most popular technical solutions are coroutine and JVM virtual threads. However, in our opinion, these techniques are effective in alleviating the problem of low CPU utilization due to suspended threads, but they do not alleviate the problem of having to carefully design our objects due to concurrency competition.</p> 
 <p>The main reason the problem has gotten so bad we believe is that the current mainstream programming languages and object-oriented programming paradigms are missing some of their key features! That is, the lack of organization of concurrency and the lack of organization of execution flow! Concurrency and execution flow are currently coupled with objects, which was not a problem in early single-threaded environments, but becomes very serious in multi-threaded, multi-CPU environments!</p> 
 <p>Organizing concurrency and execution flow is where the Actor model excels! With the advent of <code>Scala 3</code>, we saw the possibility of designing an Actor programming tool that was more in line with object-oriented thinking. So, after a long period of conceptualization, I designed <code>otavia</code> and its associated toolkit. The goal is to explore a simpler and safer programming paradigm to meet the current challenges. Also hope to open up a new idea to provide everyone to promote the development of programming tools!</p> 
 <p>We believe that a better programming hierarchy would look like the following, and the design of <code>otavia</code> follows this hierarchy</p> 
 <p><strong>System &gt; Process &gt; Threads &gt; Virtual Threads/Stacked coroutines &gt; <code>Actor &gt; Objects &gt; Functions</code></strong></p> 
 <p>In this hierarchical design, the Actor is the end point of concurrency, i.e., the Actor and its subsequent parts should all run single-threaded! Actors communicate with each other by sending messages, and multiple messages are processed one by one in the Actor's mailbox in a single-threaded fashion.The logic inside the Actor can be either object-oriented or functional, or even a combination of them, as in <code>Scala</code>! Now everything is simple again and you can boldly use objects without worrying about that wild herd of bulls!</p> 
 <p>'otavia' is a very interesting project, which is currently in the incubation stage. If you are interested, any contribution from you is warmly welcome! We would also love to hear your suggestions or criticisms about the project. All your comments will ultimately help us to improve the quality of the project! You can also give a like to the project to encourage the contributors to the project! You can also give the project a star to encourage contributors!</p> 
 <ul> 
  <li><a href="https://github.com/otavia-projects/otavia">GitHub - otavia-projects/otavia Your shiny new IO &amp; Actor programming model!</a></li> 
  <li><a href="https://github.com/otavia-projects">GitHub - otavia-projects Ecosystem for otavia project.</a></li> 
 </ul> 
</section> 
<section id="core-runtime-1"> 
 <h2 class="h500"><a href="#core-runtime-1" class="anchor"></a>Core Runtime</h2> 
 <p>The basic unit for managing concurrency in <code>otavia</code> is the <code>Actor</code>, the user only needs to implement various customized <code>Actors</code> and then send messages between the <code>Actors</code> to achieve the overall system functionality. However, the ideal <code>Actor</code> programming model is not easy to achieve, because real programming scenarios involve not only the interaction of components inside the program, but also the interaction with other components outside the system, which in turn involves IO programming and even timed tasks. To meet these needs, <code>otavia</code> adds some new components to the Actor model. The core components that make up the <code>otavia</code> runtime are:</p> 
 <ul> 
  <li><code>Actor</code>: An <code>Actor</code> is the basic unit of concurrency in <code>otavia</code> and it has two basic subclasses. An <code>Actor</code> communicates with each other by sending messages. An <code>Actor</code> can also interact with other components of the <code>ActorSystem</code> by way of <code>Event</code>. The types of <code>Event</code> are fixed and cannot be customized by the developer. 
   <ul> 
    <li><code>StateActor</code>: a normal <code>Actor</code>.</li> 
    <li><code>ChannelsActor</code>: <code>Actor</code> for handling IO.</li> 
   </ul> </li> 
  <li><code>ActorSystem</code>: A container for <code>Actor</code> instances that is responsible for creating <code>Actor</code> instances, managing the life cycle of <code>Actor</code> instances, and scheduling the execution of <code>Actor</code> instances.</li> 
  <li><code>Timer</code>: Generates a timed event, generates a timeout <code>Event</code> and sends it to the relevant <code>Actor</code>.</li> 
  <li><code>Reactor</code>: Processes IO commands submitted by the <code>ChannelsActor</code>, listens for IO events, handles IO reads and writes, and sends the IO results to the <code>ChannelsActor</code> as an <code>Event</code>.</li> 
  <li><code>Address</code>: <code>Actor</code> instances are isolated from each other and can only communicate with each other by sending messages via <code>Address</code>.</li> 
  <li><code>Message</code>: Used to communicate between <code>Actors</code>, there are three basic types of messages: <code>Notice</code>, <code>Reply</code>, and <code>Ask[R &lt;: Reply]</code>, and user-defined messages must inherit one or more of these.</li> 
 </ul> 
 <p><img src="../images/programming_model.drawio.svg" alt=""></p> 
 <p>To program with <code>otavia</code>, the user must first start an instance of <code>ActorSystem</code>, which represents the <code>otavia</code> runtime. The <code>ActorSystem</code> contains the thread pool that schedules the <code>Actor</code> instance to run, the <code>Timer</code> component, and the <code>Reactor</code> component. Next the user simply starts their own <code>Actor</code> instance using <code>ActorSystem</code>. The <code>ActorSystem</code> returns the <code>Address</code> of the corresponding <code>Actor</code> instance to the caller. Next, the user can send messages to the <code>Actor</code> via this <code>Address</code>. Unlike object-oriented method calls, sending a message does not directly execute the logic that processes the message; instead, it puts the message into the <code>Actor</code>'s mailbox and waits for it to be processed. Once the <code>Actor</code> has a message in its mailbox that can be processed, the <code>ActorSystem</code> schedules an idle thread to execute the <code>Actor</code> instance.</p> 
 <p><img src="../images/actor_instance.drawio.svg" alt=""></p> 
 <p>Another condition for an <code>Actor</code> instance to get thread execution is to receive an <code>Event</code>, which is also put in the <code>Actor</code> mailbox for processing. In <code>otavia</code>, events can only be generated by <code>Timer</code> and <code>Reactor</code>, and users only need to care about <code>TimerEvent</code> generated by <code>Timer</code> when programming. The processing of <code>ReactorEvent</code> produced by <code>Reactor</code> is further encapsulated by <code>ChannelsActor</code>.</p> 
</section> 
<section id="event-2"> 
 <h2 class="h500"><a href="#event-2" class="anchor"></a>Event</h2> 
 <p>An <code>Event</code> is the basic unit of interaction between an <code>Actor</code> and the <code>ActorSystem</code> runtime, and its type is fixed and cannot be customized by the developer. There are two main types of <code>Event</code>s</p> 
 <ul> 
  <li><code>TimerEvent</code> : Generated by <code>Timer</code> to notify a timeout event. Only <code>TimeoutEvent</code> is used directly in programming. The remaining <code>TimerEvent</code>s are used to support other timeout mechanisms and are encapsulated by <code>Actor</code>.</li> 
  <li><code>ReactorEvent</code>: Generated by <code>Reactor</code> to notify an IO event. Developer does not need to deal with this <code>Event</code> directly, it is encapsulated by <code>ChannelsActor</code>.</li> 
 </ul> 
 <p>The <code>ActorSystem</code> runtime sends an <code>Event</code> to the <code>Actor</code> instance and does not call the <code>Actor</code> instance directly; instead, it puts the <code>Event</code> into the <code>Actor</code> instance's mailbox, and the <code>ActorSystem</code> runtime allocates free threads to dispatch the <code>Actor</code> instance for execution.</p> 
</section> 
<section id="message-model-1"> 
 <h2 class="h500"><a href="#message-model-1" class="anchor"></a>Message model</h2> 
 <p>A message is a special object used by <code>Actor</code> for communication, and it is recommended that it be defined using the <code>case class</code>. <code>otavia</code> categorizes the types of messages according to their usage in order to ensure compile-time safety in message sending.</p> 
 <p><img src="../images/message_types.drawio.svg" alt=""></p> 
 <p>According to the purpose of the message, <code>otavia</code> divides the messages into two types, the <code>Call</code> message is a request message which is used to ask the <code>Actor</code> for an execution process and expects a reply message. A <code>Reply</code> message is a reply message. It's kind of like a method abstraction. Let's see how we define a method. First, we need to give the method a name, then we need to define the parameters of the method, and then we need to define the type of the return value of the method. In <code>otavia</code>, <code>Call</code> represents the method name and method parameters, and <code>Reply</code> represents the return value type. Since sending a message is more expensive than calling a method, <code>Call</code> is simplified to <code>Notice</code> in <code>otavia</code> for the case where the method has a return type of <code>Unit</code>, and the case where a return value is required is specialized to <code>Ask[R &lt;: Reply]</code>, where a <code>Notice</code> message does not need to return a <code>Reply</code> message, as in the case of A method with a return value of <code>Unit</code> has no actual return value.</p> 
 <p><img src="../images/message_model.drawio.svg" alt=""></p> 
 <p>An <code>Ask</code> is a trait with a type parameter <code>R &lt;: Reply</code> that specifies the type of the specific <code>Reply</code> message that this <code>Ask</code> message expects to get. So an <code>Actor</code> in <code>otavia</code> can be compile-time type-safe for sending messages by simply constraining the types of <code>Call</code> messages it can receive via the type parameter. The type parameter of <code>Actor</code> is:</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait Actor[+M &lt;: Call]
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>When creating an instance of <code>Actor</code> using <code>otavia</code>, it does not return the instance itself, but rather the <code>Address</code> that represents the instance, with the type parameter of <code>Address</code> being the same as that of <code>Actor</code>.</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait Address[-M &lt;: Call]
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>So we can only send messages of type <code>M</code> to <code>Address</code> which is limited by <code>Actor</code>. The <code>Reply</code> message is sent via the <code>return</code> method of <code>Stack</code>, which is associated with the type of the <code>Call</code> message, so sending a <code>Reply</code> message is also compile-time type-safe. We'll talk more about <code>Stack</code> later.</p> 
</section> 
<section id="actor-2"> 
 <h2 class="h500"><a href="#actor-2" class="anchor"></a>Actor</h2> 
 <p>There are two basic types of <code>Actor</code> in <code>otavia</code>, <code>StateActor</code> and <code>ChannelsActor</code>, and developers can choose to inherit from one of them according to their needs.</p> 
 <p><img src="../images/two_types_actor.drawio.svg" alt=""></p> 
 <p><code>StateActor</code>: A generic <code>Actor</code> that developers can implement to manage state and send and receive messages. This <code>Actor</code> can also interact with a <code>Timer</code> to register a timeout event. When the timeout event is triggered, the <code>Timer</code> sends a <code>TimeoutEvent</code> to the <code>StateActor</code>, and then the <code>ActorSystem</code> schedules the <code>StateActor</code> to execute to handle the <code>TimeoutEvent</code>.</p> 
 <p><code>ChannelsActor</code>: Based on the functionality of <code>StateActor</code>, we have added the ability to manage <code>Channel</code>s. <code>Channels</code> in <code>otavia</code> are ported from Netty, and are basically the same as Netty. However, unlike Netty, <code>Channel</code> in <code>otavia</code> must be bound to a <code>ChannelsActor</code> and run as part of the <code>ChannelsActor</code>.</p> 
 <p>For ease of use, <code>otavia</code> abstracts the following common <code>Actor</code>s according to different scenarios, and you can choose to inherit one of them to fulfill your needs:</p> 
 <p><img src="../images/actor_type.drawio.svg" alt=""></p> 
</section> 
<section id="stack-2"> 
 <h3 class="h400"><a href="#stack-2" class="anchor"></a>Stack</h3> 
 <p><code>Stack</code> is the carrier that manages the execution of messages in <code>Actor</code>. When an <code>Actor</code> handles a message of type <code>Call</code>, the message is not passed in directly, but is loaded into a <code>Stack</code> which is then passed to the <code>Actor</code> for execution. A <code>Notice</code> message is loaded into a <code>NoticeStack</code> that executes the <code>resumeNotice</code> method; an <code>Ask</code> message is loaded into an <code>AskStack</code> that executes the <code>resumeAsk</code> method. A developer implementation of <code>Actor</code> needs to implement the following methods to handle <code>Call</code> messages.</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>protected def resumeAsk(stack: AskStack[M &amp; Ask[? &lt;: Reply]]): Option[StackState]
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>protected def resumeNotice(stack: NoticeStack[M &amp; Notice]): Option[StackState]
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p><code>Stack</code> contains a <code>StackState</code> with an initial value of <code>stackstate.start</code>. The return value of the <code>resumeXXX</code> method <code>Option[StackState]</code> means that Stack switches to a new <code>StackState</code> after each resumeXXX execution. <code>Stack</code> ends with the <code>return</code> method, which itself returns a value of <code>None</code>, meaning that <code>Stack</code> no longer switches to the new <code>StackState</code>. If <code>Stack</code> is <code>AskStack</code>, the <code>return</code> method requires an input <code>Reply</code> message as a reply to the <code>Ask</code> message.</p> 
 <p><img src="../images/stack_resume.drawio.svg" alt=""></p> 
 <p>A <code>StackState</code> must be associated with one or more <code>Future</code>s. When the <code>resumable</code> method of the <code>StackState</code> returns <code>true</code> or all associated <code>Future</code>s are completed, <code>resumeXXX</code> will be called again to execute the <code>Stack</code>. Note that the <code>Future</code> here is not a <code>Future</code> from the <code>Scala</code> standard library; <code>otavia</code> implements its own <code>Future/Promise</code> system for receiving asynchronous messages and triggering the re-execution of <code>Stacks</code>.</p> 
</section> 
<section id="types-of-stack-1"> 
 <h4 class="h300"><a href="#types-of-stack-1" class="anchor"></a>Types of Stack</h4> 
 <p>Different messages have different <code>Stack</code> subclasses.</p> 
 <ul> 
  <li><code>NoticeStack</code>: Manages the execution of <code>Notice</code> messages.</li> 
  <li><code>AskStack</code>: Manages the execution of <code>Ask</code> messages.</li> 
  <li><code>BatchNoticeStack</code>: Used to batch execute <code>Notice</code> messages.</li> 
  <li><code>BatchAskStack</code>: Used to batch execute <code>Ask</code> messages.</li> 
  <li><code>ChannelStack</code>: Executes requests sent by <code>Channel</code>.</li> 
 </ul> 
 <p><strong>Developer-defined messages may inherit both the <code>Notice</code> and <code>Ask</code> traits, and whether they end up being treated as <code>Notice</code> messages or <code>Ask</code> messages depends on how the message was sent: If it is sent using the <code>notice</code> method of <code>Address</code>, it is treated as a <code>Notice</code> message; if it is sent by the <code>ask</code> method, it is treated as an <code>Ask</code> message.</strong></p> 
</section> 
<section id="types-of-future-1"> 
 <h4 class="h300"><a href="#types-of-future-1" class="anchor"></a>Types of Future</h4> 
 <p>A <code>Future</code> is a receiver for an asynchronous message, and whenever a <code>Future</code> completes, the <code>StackState</code> associated with it is checked to see if the conditions for execution are met. Once satisfied, the <code>resumeXXX</code> method is called again to execute the <code>Stack</code>. There are two types of <code>Future</code>s according to their purpose.</p> 
 <ul> 
  <li><code>MessageFuture</code>: Used to receive a <code>Reply</code> message or a <code>TimeoutReply</code> message generated due to a timeout.</li> 
  <li><code>ChannelFuture</code>: Get the result of a <code>Channel</code> execution or a message from a <code>Channel</code>.</li> 
 </ul> 
</section> 
<section id="zero-cost-abstraction-1"> 
 <h4 class="h300"><a href="#zero-cost-abstraction-1" class="anchor"></a>Zero-cost abstraction</h4> 
 <p>Although we use <code>Stack</code>, <code>Future</code>, etc. to manage the execution of messages, we don't have to worry about the system sending too many messages and creating too many extra objects that will put a strain on the GC. Because these objects are created by the <code>otavia</code> runtime and are managed by the object pool, object reuse is maximized. Also, developer-implemented <code>StackState</code> can use the pool if it is used by a high frequency. <code>otavia</code> provides a very simple way to use the object pool. You can refer to the <a href="https://github.com/otavia-projects/otavia/blob/main/core/src/cc/otavia/core/stack/helper/FutureState.scala">FutureState</a> implementation to learn how to use object pooling.</p> 
</section> 
<section id="advantages-of-using-stack-to-manage-message-execution-1"> 
 <h4 class="h300"><a href="#advantages-of-using-stack-to-manage-message-execution-1" class="anchor"></a>Advantages of using Stack to manage message execution</h4> 
 <p>By using <code>Stack</code> to manage the execution of messages, we can manage dependencies between messages very well, and sending a message is more like calling a method of an object directly. Going further, we can even implement a set of <code>async/await</code> syntax based on the CPS (Continuation Passing Style) using <code>Scala 3</code> metaprogramming tools. This is the goal of the project <a href="https://github.com/otavia-projects/otavia-async">otavia-async</a>. If you are interested in this project, you are more than welcome to contribute!</p> 
</section> 
<section id="kinds-of-channelsactor-1"> 
 <h3 class="h400"><a href="#kinds-of-channelsactor-1" class="anchor"></a>Kinds of ChannelsActor</h3> 
 <p>In order to better manage different <code>Channel</code>s, <code>otavia</code> implements several different kinds of <code>ChannelsActor</code>, they are:</p> 
 <ul> 
  <li><code>AcceptorActor</code>: manages the <code>Channel</code> that listens for TCP connections, which needs to instantiate a set of <code>AcceptedWorkerActor</code>s as working <code>Actor</code>s. Normal <code>Channel</code>s that are accepted by the listening <code>Channel</code> are wrapped in a message and sent to one of the <code>AcceptedWorkerActor</code>s, and managed by the selected <code>AcceptedWorkerActor</code>.</li> 
  <li><code>AcceptedWorkerActor</code>: The working <code>Actor</code> for the <code>AcceptorActor</code>.</li> 
  <li><code>SocketChannelsActor</code>: manages the TCP client <code>Channel</code>.</li> 
  <li><code>DatagramChannelsActor</code>: manages the UDP <code>Channel</code>.</li> 
 </ul> 
 <p>All of these types of <code>ChannelsActor</code> can manage file <code>Channel</code>, and if you only need to use file <code>Channel</code>, you can just inherit <code>ChannelsActor</code>.</p> 
</section> 
<section id="life-cycle-of-an-actor-1"> 
 <h3 class="h400"><a href="#life-cycle-of-an-actor-1" class="anchor"></a>Life cycle of an Actor</h3> 
 <p>The entire life cycle of an <code>Actor</code> is managed by the <code>otavia</code> runtime. When <code>ActorSystem</code> creates an <code>Actor</code> object, it immediately returns the <code>Address</code> of the <code>Actor</code> object to the caller. At the same time, the <code>Actor</code> object is placed in a mount queue waiting to be mounted to <code>ActorSystem</code>. Only after the <code>Actor</code> object is mounted, the runtime schedules the <code>Actor</code> to process the <code>Message</code> or <code>Event</code> in the mailbox. Runtime-related properties are set when the <code>Actor</code> object is mounted, so runtime-related properties within the <code>Actor</code> can only be used after the object is mounted, such as <code>logger</code>, <code>context</code>, and so on. <code>Actor</code> provides some hook methods for running at different lifecycles.</p> 
 <ul> 
  <li><code>afterMount</code>: Called after the <code>Actor</code> object is mounted to <code>ActorSystem</code>.</li> 
  <li><code>beforeRestart</code>: Called before reboot.</li> 
  <li><code>restart</code>: Methods for restarting <code>Actor</code> instances.</li> 
  <li><code>afterRestart</code>: Called after a reboot.</li> 
  <li><code>AutoCleanable.cleaner</code>: If your implementation of <code>Actor</code> needs to clean up some unsafe resources, inherit the <code>AutoCleanable</code> trait and implement the <code>cleaner</code> method.</li> 
 </ul> 
 <p>Although the life cycle of <code>Actor</code> instances is managed by <code>ActorSystem</code>, their destruction is still handled by the JVM's garbage collection. If an <code>Actor</code> instance is no longer referenced by any GC root object, it is garbage collected by the JVM. If your <code>Actor</code> has some unsafe resources that cannot be garbage collected by the JVM, you can extend <code>AutoCleanable</code> and implement the <code>cleaner</code> method. The <code>cleaner</code> method creates a custom <code>ActorCleaner</code> object to clean up the unsafe resources. Because <code>ActorCleaner</code> relies on the JVM's phantom references to identify <code>Actor</code>s that will be garbage collected, you need to be careful when implementing <code>ActorCleaner</code> to ensure that it doesn't hold a reference to the <code>Actor</code> object or the address of the <code>Actor</code> or the <code>Actor</code> will never be garbage collected.</p> 
 <p>The following figure shows the complete lifecycle of an <code>Actor</code>:</p> 
 <p><img src="../images/actor_life_cycle.drawio.svg" alt=""></p> 
</section> 
<section id="channel-2"> 
 <h2 class="h500"><a href="#channel-2" class="anchor"></a>Channel</h2> 
 <p>In <code>otavia</code>, a <code>Channel</code> represents an IO object, such as an open file, a network connection, and so on. Since <code>Channel</code> is ported from Netty, the basic components are similar to Netty, such as <code>ChannelPipeline</code> <code>ChannelHandler</code> <code>ChannelHandlerContext</code>, etc., and work in the same way as Netty.</p> 
 <p><img src="../images/architecture_of_channel.drawio.svg" alt=""></p> 
 <p>But there are also some adjustments that need to be made in order for <code>Channel</code> to work better with <code>otavia</code>'s <code>ChannelsActor</code>:</p> 
 <ol> 
  <li>Netty's <code>Channel</code> needs to be registered to <code>EventLoop</code> after it is created. The <code>EventLoop</code> is a thread that listens for IO events and then schedules the associated <code>Channel</code> for execution. Similarly for outbound calls on <code>Channel</code>, they need to be converted into tasks to be submitted to the <code>EventLoop</code> thread for queuing. There is no <code>EventLoop</code> component in <code>otavia</code>. The <code>Channel</code> in <code>otavia</code> needs to be mounted on a <code>ChannelsActor</code> after it has been successfully created, and then the <code>ChannelsActor</code> will register the <code>UnsafeChannel</code> of the <code>Channel</code> with the <code>Reactor</code>. The <code>Reactor</code> listens for IO events on the associated <code>Channel</code> and generates a <code>ReactorEvent</code> to send to the <code>ChannelsActor</code>. When the <code>ChannelsActor</code> is scheduled for execution, it assigns the <code>ReactorEvent</code> to the relevant <code>Channel</code> to execute the inbound process.</li> 
  <li>Netty's <code>EventLoop</code> not only listens to IO events, but also schedules the relevant <code>Channel</code> to execute when an IO event occurs, and the listening to IO, reading and writing of IO data, and execution of the <code>ChannelPipeline</code> are all in the same <code>EventLoop</code> thread. However, in <code>otavia</code>, listening to IO, reading and writing IO data are handled by <code>Reactor</code>, and then the related <code>ReactorEvent</code> is generated and sent to <code>ChannelsActor</code>, which is responsible for scheduling the execution of <code>ChannelPipeline</code>.</li> 
  <li>All business logic in Netty must be encapsulated into a <code>ChannelHandler</code> and then placed into a <code>ChannelPipeline</code>. If an inbound event reaches the end of the <code>ChannelPipeline</code> and the <code>TailHandler</code> still hasn't processed it, then Netty ignores it. However, inbound events in <code>otavia</code> that reach the <code>TailHandler</code> continue on to the <code>Inflight</code> component within the <code>Channel</code>, which is then distributed by <code>Inflight</code> to the <code>Stack</code> within the <code>ChannelsActor</code> for processing. In fact, the role of the <code>ChannelPipeline</code> in <code>otavia</code> is more focused on byte-sequence conversion and encoding, such as TLS, compression, serialization and deserialization of data objects, etc. Other complex business logic is handled directly by passing deserialized objects to the <code>Inflight</code> component of the <code>Channel</code>, which is then passed to the <code>ChannelsActor</code> for further processing.</li> 
 </ol> 
</section> 
<section id="channel-behavioral-abstractions-1"> 
 <h3 class="h400"><a href="#channel-behavioral-abstractions-1" class="anchor"></a>Channel Behavioral Abstractions</h3> 
 <p>We abstract the behavior of <code>Channel</code> through two data structures:</p> 
 <p><code>ChannelFuture</code>, which is a subclass of <code>Future</code>, so it can be managed by <code>StackState</code> of <code>Stack</code>, which we introduced earlier. A <code>ChannelFuture</code> makes a request to a <code>Channel</code> on behalf of a <code>ChannelsActor</code> and expects to get a reply from the <code>Channel</code>, which can be either an IO-ready event or a specific message (e.g., send an HTTP request, get an HTTP response using a <code>ChannelFuture</code>). Usage of <code>ChannelFuture</code> is restricted to <code>ChannelAddress</code>. The <code>ChannelAddress</code> is a kind of encapsulation for more standardized use of <code>Channel</code>. Inside the <code>ChannelsActor</code>, except for some special methods that can access <code>Channel</code> directly, the rest of the access to <code>Channel</code> can only be done through the <code>ChannelAddress</code>; The other data structure is the <code>ChannelStack</code>, this kind of data structure is <code>ChannelStack</code>.</p> 
 <p>The other data structure is <code>ChannelStack</code>, an object that makes a request on behalf of the <code>Channel</code> to our <code>ChannelsActor</code>. This is a very common scenario when writing a web server program, for example, a <code>Channel</code> receives an HTTP request and pass it to a <code>ChannelsActor</code> for specific business processing. This HTTP request is put into a <code>ChannelStack</code> object and sent to the <code>ChannelsActor</code> for processing. A <code>ChannelStack</code> is a <code>Stack</code> whose return value is written to a <code>ChannelPipeline</code> in response to an external program.</p> 
 <p>Note that the <code>ChannelFuture</code> datatype is also available in Netty, but it is used differently in <code>Netty</code> than it is in <code>otavia</code>! Each call to the outbound method of <code>Channel</code> in Netty is associated with a <code>ChannelFuture</code>, but this <code>ChannelFuture</code> is used to get the result of the call itself. If you want to make a request to <code>Channel</code> and expect a data reply from the network, you need to get it some other way. But the <code>ChannelFuture</code> in <code>otavia</code> is a higher level abstraction that represents the expected data response to a network request!</p> 
</section> 
<section id="channelpipeline-2"> 
 <h3 class="h400"><a href="#channelpipeline-2" class="anchor"></a>ChannelPipeline</h3> 
 <p>The <code>ChannelPipeline</code> is basically the same as the <code>ChannelPipeline</code> in Netty, with <code>HeadHandler</code> and <code>TailHandler</code> as the first and last nodes, respectively. When the <code>Channel</code> is initialized, the user can add a custom <code>ChannelHandler</code> to the <code>ChannelPipeline</code> via <code>Channel</code>. Like Netty, <code>ChannelHandler</code> is wrapped by <code>ChannelHandlerContext</code>, which then concatenates all <code>ChannelHandler</code>s into a queue for sequential execution.</p> 
 <p>A <code>ReactorEvent</code> sent by a <code>Reactor</code> to a <code>ChannelsActor</code> triggers an inbound event for the <code>ChannelPipeline</code>. inbound events are passed from the <code>HeadHandler</code> to the <code>TailHandler</code>. Calls to the outbound-related methods of the <code>Channel</code> trigger outbound events from the <code>TailHandler</code> to the <code>HeadHandler</code>. outbound events arrive at the <code>HeadHandler</code> and are ultimately converted into commands that are submitted to the <code>Reactor</code>.</p> 
 <p><img src="../images/pipeline.drawio.svg" alt=""></p> 
</section> 
<section id="channel-inflight-2"> 
 <h3 class="h400"><a href="#channel-inflight-2" class="anchor"></a>Channel Inflight</h3> 
 <p>The <code>Inflight</code> is not a real component, it is just a representation of some of the data structures and mechanisms in the <code>Channel</code>. Users don't need to interact with them directly, they just need to set some properties through the <code>setOption</code> method of the <code>Channel</code> to control their behavior.</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// source code in AbstractChannel
</span><span line-number="2" class=""><span class="tooltip-container"></span>// outbound futures which is write to channel and wait channel reply
</span><span line-number="3" class=""><span class="tooltip-container"></span>private val inflightFutures: QueueMap[ChannelPromise] = new QueueMap[ChannelPromise]()
</span><span line-number="4" class=""><span class="tooltip-container"></span>// outbound futures which is waiting channel to send
</span><span line-number="5" class=""><span class="tooltip-container"></span>private val pendingFutures: QueueMap[ChannelPromise] = new QueueMap[ChannelPromise]()
</span><span line-number="6" class=""><span class="tooltip-container"></span>// inbound stack which is running by actor
</span><span line-number="7" class=""><span class="tooltip-container"></span>private val inflightStacks: QueueMap[ChannelStack[?]] = new QueueMap[ChannelStack[?]]()
</span><span line-number="8" class=""><span class="tooltip-container"></span>// inbound stack to wait actor running
</span><span line-number="9" class=""><span class="tooltip-container"></span>private val pendingStacks: QueueMap[ChannelStack[?]] = new QueueMap[ChannelStack[?]]()
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p><img src="../images/channel_inflight.drawio.svg" alt=""></p> 
 <p><code>Inflight</code> is an abstraction of the control of sending packets for network communication. How do we typically use a network connection? In most cases, we send a request packet and wait for the response packet to be returned. Until the response packet is returned, we can't send another request packet over the network connection. But this is an inefficient use of the network connection, so there are many application layer protocols that support sending multiple request packets over a single network connection, such as the pipeline mechanism in HTTP 1.1, the pipeline mechanism in redis, and so on. However, due to the complexity of implementing these mechanisms, many applications do not support this type of optimization.</p> 
 <p>In <code>otavia</code>, however, the powerful <code>Inflight</code> mechanism makes it very easy to do this! Now that we know what <code>ChannelFuture</code> and <code>ChannelStack</code> are used for in <code>Channel</code>, the pipeline optimization mentioned above can simply be understood as a single <code>Channel</code> handling multiple <code>ChannelFuture</code>s or <code>ChannelStacks</code>s at the same time. There are several components in <code>Channel</code> that support this efficient use of network connections:</p> 
 <ul> 
  <li><code>inflightFutures</code>: A <code>ChannelFuture</code> that has gone into the <code>ChannelPipeline</code> for processing.</li> 
  <li><code>pendingFutures</code>: A <code>ChannelFuture</code> that is still queued for processing into the <code>ChannelPipeline</code>.</li> 
  <li><code>inflightStacks</code>: A <code>ChannelStack</code> that has gone into a <code>ChannelsActor</code> for execution.</li> 
  <li><code>pendingStacks</code>: A <code>ChannelStack</code> that is still queuing up to enter the <code>ChannelsActor</code> for execution.</li> 
 </ul> 
 <p>You can control the behavior of these components to adapt to different ways of working with network connections through <code>setOption</code>:</p> 
 <ul> 
  <li><code>CHANNEL_FUTURE_BARRIER</code>: A function of type <code>AnyRef =&gt; Boolean</code> that checks whether the request value of a <code>ChannelFuture</code> is a barrier, and if a request is a barrier, it must wait for the <code>inflightFutures</code> to finish processing before it can enter the <code>inflightFutures</code>. At the same time, <code>inflightFutures</code> can only process one <code>ChannelFuture</code> when processing a barrier, and can only continue to process the <code>ChannelFuture</code> in <code>pendingFutures</code> when it finishes. The default value is <code>_ =&gt; false</code>.</li> 
  <li><code>CHANNEL_STACK_BARRIER</code>: Used to set a function of type <code>AnyRef =&gt; Boolean</code> to check if the request value of a <code>ChannelStack</code> is a barrier, and if a request is a barrier then it must wait for the <code>inflightStacks</code> to finish processing before it can enter the <code>inflightStacks</code>. Also <code>inflightStacks</code> can only process one <code>ChannelStack</code> when processing a barrier, and can only continue to process <code>ChannelStacks</code> in <code>pendingStacks</code> when processing is complete. The default value is <code>_ =&gt; true</code>.</li> 
  <li><code>CHANNEL_MAX_FUTURE_INFLIGHT</code>: The maximum number of <code>ChannelFutures</code> that <code>inflightFutures</code> can process at the same time. When the maximum number is reached, new <code>ChannelFutures</code> are added to the <code>pendingFutures</code> queue and wait to be added to <code>inflightFutures</code>. The default value is 1.</li> 
  <li><code>CHANNEL_MAX_STACK_INFLIGHT</code>: The maximum number of <code>ChannelStacks</code> that <code>inflightStacks</code> can process at the same time. When the maximum number is reached, new <code>ChannelStacks</code> are added to the <code>pendingStacks</code> queue waiting to enter <code>inflightStacks</code>. The default value is 1.</li> 
  <li><code>CHANNEL_STACK_HEAD_OF_LINE</code>: Used to set whether the <code>Channel</code> processing <code>ChannelStack</code> is line head blocking. When <code>inflightStacks</code> have multiple <code>ChannelStacks</code> entering the <code>ChannelsActor</code> at the same time, the later initiated <code>ChannelStack</code> may finish earlier than the first initiated <code>ChannelStack</code>. When head blocking is set, the later completed <code>ChannelStacks</code> cannot directly execute the subsequent <code>ChannelPipeline</code>, but have to wait for the completion of all the <code>ChannelStacks</code> that were initiated first before they can be executed. The default value is <code>false</code>.</li> 
 </ul> 
 <p>Setting these values in combination will result in more correct and efficient use of network connection resources in different scenarios!</p> 
</section> 
<section id="reactor-2"> 
 <h2 class="h500"><a href="#reactor-2" class="anchor"></a>Reactor</h2> 
 <p>The <code>Reactor</code> is the component in <code>otavia</code> that performs unsafe IO work and is transparent to the user of <code>otavia</code>. <code>Reactor</code> is responsible for receiving IO commands from <code>ChannelsActor</code> and generating the associated <code>ReactorEvent</code> to send to <code>ChannelsActor</code>. However, this is all encapsulated by <code>ChannelsActor</code> and most users don't need to worry about <code>Reactor</code>. The specific tasks of <code>Reactor</code> are to execute IO commands submitted by <code>ChannelsActor</code>, listen for IO events, read and write IO data, and send <code>ReactorEvent</code> to <code>ChannelsActor</code>.</p> 
 <p>The default <code>Reactor</code> in <code>otavia</code> is based on NIO. However, since <code>Reactor</code> uses the SPI mechanism to implement the IO transport layer, we can also extend the relevant interfaces to use more advanced IO techniques such as epoll, io_uring, and so on, to realize a more high-performance IO transport layer. Since this is an SPI implementation, replacing another IO transport layer implementation will not affect the business code we write at all, we just need to include the relevant JAR in our CLASSPATH when we run the program. The goal of the <a href="https://github.com/otavia-projects/native-transport">native-transport</a> project in the <a href="https://github.com/otavia-projects">otavia ecosystem</a> is to implement a higher-performance IO transport layer based on epoll and io_uring! If you are interested, your contributions are warmly welcomed!</p> 
</section> 
<section id="timer-4"> 
 <h2 class="h500"><a href="#timer-4" class="anchor"></a>Timer</h2> 
 <p>All timeout related functionality in <code>otavia</code> is supported by <code>Timer</code>. The <code>Timer</code> is one of the core components of the <code>otavia</code> runtime, and provides APIs that allow developers to register a timeout event trigger. When the trigger condition is met, <code>Timer</code> generates a <code>TimerEvent</code> and sends it to the registered address. The underlying implementation of <code>Timer</code> is ported from <code>HashedWheelTimer</code> in Netty.</p> 
</section> 
<section id="actor-dependency-injection-1"> 
 <h2 class="h500"><a href="#actor-dependency-injection-1" class="anchor"></a>Actor Dependency Injection</h2> 
 <p><code>Scala 3</code> provides a powerful <a href="https://docs.scala-lang.org/scala3/reference/new-types/match-types.html">Match Types</a> mechanism, which allows us to succinctly inject an <code>Actor</code>'s <code>Address</code> through the <code>Actor</code>'s type, and this behavior is compile-time type-safe!</p> 
</section> 
<section id="other-core-modules-in-the-ecosystem-1"> 
 <h2 class="h500"><a href="#other-core-modules-in-the-ecosystem-1" class="anchor"></a>Other core modules in the ecosystem</h2> 
 <p><code>otavia</code> contains an extensive ecosystem beyond the core runtime. The following describes the design goals for only some of the modules that are more closely related to the core. For other modules you can check out the <a href="https://github.com/otavia-projects">otavia ecosystem</a>.</p> 
</section> 
<section id="cps-transformation-1"> 
 <h3 class="h400"><a href="#cps-transformation-1" class="anchor"></a>CPS transformation</h3> 
 <p>The execution of a <code>Call</code> message in <code>otavia</code> requires a <code>Stack</code> to be started, and then the entire <code>Call</code> message execution lifecycle is managed by the <code>Stack</code>. So the <code>resumeXXX</code> method implemented by the developer needs to match the <code>StackState</code> execution and return a new <code>StackState</code>. Because the pattern is relatively fixed, we can use the <code>Scala 3</code> metaprogramming tools to implement a set of <code>async/await</code> syntaxes based on CPS transformations, which allows us to write code in a continuously blocking style.</p> 
 <p>Project repository: <a href="https://github.com/otavia-projects/otavia-async">GitHub - otavia-projects/otavia-async</a></p> 
</section> 
<section id="buffer-2"> 
 <h3 class="h400"><a href="#buffer-2" class="anchor"></a>Buffer</h3> 
 <p>Like <code>Channel</code>, <code>Buffer</code> is ported from Netty. Since <code>Channel</code> has to deal with a lot of byte-sequence conversion, serialization and deserialization, the <code>Buffer</code> API is a must. Currently, <code>Buffer</code> just keeps the API basically the same as Netty, and its implementation as well as the implementation of the memory pool has been greatly simplified.</p> 
 <p>Another inconsistency with Netty is that <code>otavia</code> removes <code>CompositeBuffer</code> and instead <code>otavia</code> introduces <code>AdaptiveBuffer</code>.</p> 
 <p>An <code>AdaptiveBuffer</code> is a special kind of <code>Buffer</code> that can be infinitely scalable and burned later. Because <code>AdaptiveBuffer</code> has a <code>BufferAllocator</code> associated with it, it automatically allocates some memory when it runs out of space, and if the data is read, the read memory is automatically freed to the <code>BufferAllocator</code>. <code>AdaptiveBuffer</code> is a data structure that is heavily used in <code>Channel</code>. IO data received from the <code>Reactor</code> is written to the <code>AdaptiveBuffer</code> before being passed to the <code>ChannelPipeline</code>. At the same time, the <code>Channel</code>'s <code>write</code> also ends up writing data to the <code>AdaptiveBuffer</code>, sending the bytes of data inside the <code>AdaptiveBuffer</code> to the <code>Reactor</code> to write to the IO object via the <code>flush</code> method.</p> 
</section> 
<section id="codec-2"> 
 <h3 class="h400"><a href="#codec-2" class="anchor"></a>codec</h3> 
 <p>The <code>codec</code> module provides some common abstract classes for <code>ChannelHandler</code>, and developers can choose to inherit one of them according to their needs. <code>otavia</code> categorizes <code>ChannelHandler</code> according to its position in the <code>ChannelPipeline</code> and its function.</p> 
 <ul> 
  <li><code>Byte2ByteXXcoder</code>: Used for conversion of byte sequences, where the input and output are byte sequences, such as TLS, compression, etc.</li> 
  <li><code>Byte2MessageDecoder</code>: Used for object deserialization where the input is a sequence of bytes and the output is a data object.</li> 
  <li><code>Message2ByteEncoder</code>: Used for object serialization where the input is a data object and the output is a sequence of bytes.</li> 
  <li><code>Message2MessageXXcoder</code>: Object conversions, where both input and output are objects.</li> 
 </ul> 
 <p>These types of <code>ChannelHandler</code>s in the <code>ChannelPipeline</code> are not required and can be combined by the developer according to their needs.</p> 
 <p><img src="../images/channel_handler_types.drawio.svg" alt=""></p> 
 <p>In addition to this, the <code>codec</code> module provides some tool classes and implementations of the completed <code>ChannelHandler</code>, such as Base64, compression, and so on.</p> 
</section> 
<section id="serialization-deserialization-framework-1"> 
 <h3 class="h400"><a href="#serialization-deserialization-framework-1" class="anchor"></a>Serialization Deserialization Framework</h3> 
 <p><code>Serde</code> expects to provide a unified interface for all serialization and deserialization tools. Since most serialization deserialization frameworks in the current Scala ecosystem basically serialize to <code>java.nio.ByteBuffer</code> or <code>Array[Byte]</code>, they don't work well with <code>otavia</code>'s <code>Buffer</code> (which involves multiple memory copies and doesn't easily take advantage of the memory pool). So <code>otavia</code> introduced the <code>Serde[T]</code> interface, which uses <code>Buffer</code> as the basic serialization deserialization target. So serialization frameworks based on <code>Serde</code> implementations can work efficiently with <code>AdaptiveBuffer</code>, avoiding unnecessary memory copies and utilizing the memory pool directly. At the same time, developers can also extend <code>Buffer</code>, such as the file-based implementation of <code>Buffer</code>, to serialize objects directly into files. This makes the input and output targets of the serialization framework more flexible.</p> 
 <p><img src="../images/architecture_of_serde.drawio.svg" alt=""></p> 
</section> 
<section id="sql-2"> 
 <h3 class="h400"><a href="#sql-2" class="anchor"></a>SQL</h3> 
 <p>The standard for <code>Actor</code> access to relational databases in <code>otavia</code> references the JDBC design.</p> 
</section> 
<section id="logger-1"> 
 <h3 class="h400"><a href="#logger-1" class="anchor"></a>Logger</h3> 
 <p>SLF4A is the logging standard in <code>otavia</code> and references the design of SLF4J. You can get a <code>Logger</code> with the following code</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>Logger.getLogger(getClass, system)
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>However, there is already a <code>Logger</code> property within <code>StateActor</code> and <code>ChannelsActor</code> that developers can use directly.</p> 
</section> 
<section id="testkit-1"> 
 <h3 class="h400"><a href="#testkit-1" class="anchor"></a>Testkit</h3> 
 <p>Toolset for Testing Actors.</p> 
</section> 
<section id="the-other-1"> 
 <h3 class="h400"><a href="#the-other-1" class="anchor"></a>The other</h3> 
 <p>See more modules at <a href="https://github.com/otavia-projects">otavia ecosystem</a>.</p> 
</section></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#challenges-of-existing-programming-paradigm-1">Challenges of existing programming paradigm</a></li><li><a href="#design-principles-of-otavia-1">Design principles of otavia</a></li><li><a href="#core-runtime-1">Core Runtime</a></li><li><a href="#event-2">Event</a></li><li><a href="#message-model-1">Message model</a></li><li><a href="#actor-2">Actor</a><ul><li><a href="#stack-2">Stack</a><ul><li><a href="#types-of-stack-1">Types of Stack</a></li><li><a href="#types-of-future-1">Types of Future</a></li><li><a href="#zero-cost-abstraction-1">Zero-cost abstraction</a></li><li><a href="#advantages-of-using-stack-to-manage-message-execution-1">Advantages of using Stack to manage message execution</a></li></ul></li><li><a href="#kinds-of-channelsactor-1">Kinds of ChannelsActor</a></li><li><a href="#life-cycle-of-an-actor-1">Life cycle of an Actor</a></li></ul></li><li><a href="#channel-2">Channel</a><ul><li><a href="#channel-behavioral-abstractions-1">Channel Behavioral Abstractions</a></li><li><a href="#channelpipeline-2">ChannelPipeline</a></li><li><a href="#channel-inflight-2">Channel Inflight</a></li></ul></li><li><a href="#reactor-2">Reactor</a></li><li><a href="#timer-4">Timer</a></li><li><a href="#actor-dependency-injection-1">Actor Dependency Injection</a></li><li><a href="#other-core-modules-in-the-ecosystem-1">Other core modules in the ecosystem</a><ul><li><a href="#cps-transformation-1">CPS transformation</a></li><li><a href="#buffer-2">Buffer</a></li><li><a href="#codec-2">codec</a></li><li><a href="#serialization-deserialization-framework-1">Serialization Deserialization Framework</a></li><li><a href="#sql-2">SQL</a></li><li><a href="#logger-1">Logger</a></li><li><a href="#testkit-1">Testkit</a></li><li><a href="#the-other-1">The other</a></li></ul></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://gitter.im/scala/scala"><button class="icon-button gitter"></button></a><div class="text">Copyright (c) 2022, Yan Kun/Otavia Project</div></div><div class="text-mobile">Copyright (c) 2022, Yan Kun/Otavia Project</div></div></div></div></body></html>