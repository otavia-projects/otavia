<!DOCTYPE html><html data-pathToRoot="../"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Quick Start</title><link rel="shortcut icon" type="image/x-icon" href="../favicon.ico"></link><script type="text/javascript" src="../scripts/theme.js"></script><script type="text/javascript" src="../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../styles/theme/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../styles/nord-light.css"></link><link rel="stylesheet" href="../styles/dotty-icons.css"></link><link rel="stylesheet" href="../styles/filter-bar.css"></link><link rel="stylesheet" href="../styles/code-snippets.css"></link><link rel="stylesheet" href="../styles/searchbar.css"></link><link rel="stylesheet" href="../styles/social-links.css"></link><link rel="stylesheet" href="../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../styles/content-contributors.css"></link><link rel="stylesheet" href="../styles/fontawesome.css"></link><script type="text/javascript" src="../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../styles/staticsitestyles.css"></link><script>var pathToRoot = "../";</script><meta charset="utf-8">
<title>Hello, world!</title></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../home.html" class="logo-container"><span class="project-name h300">otavia</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">0.3.8-SNAPSHOT</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span class="project-name h300">otavia</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="index.html">Docs</a><a id="api-nav-button" class="switcher h100 " href="../index.html">API</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0 "><span class="nh de"><a href="name_from.html"><span>Name From</span></a></span></div><div class="ni n0 expanded"><span class="nh h100 selected de"><a href="#"><span>Quick Start</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="core_concept.html"><span>Core Concepts and Design</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="guide/index.html"><span>Guide</span></a></span><div class="ni n1 "><span class="nh de"><a href="guide/actor_model.html"><span>Actor Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/channel_pipeline.html"><span>Channel Pipeline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/io_model.html"><span>IO Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/ioc.html"><span>Actor IOC </span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/message_model.html"><span>Message Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/reactor_model.html"><span>Reactor Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/slf4a.html"><span>SLF4A</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="guide/serde.html"><span>Serde framework</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="module/index.html"><span>Modules</span></a></span><div class="ni n1 "><span class="nh de"><a href="module/buffer.html"><span>Buffer</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="zh/index.html"><span>中文文档</span></a></span><div class="ni n1 "><span class="nh de"><a href="zh/name_from.html"><span>名称来源</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="zh/quick_start.html"><span>快速开始</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="zh/core_concept.html"><span>核心概念与设计</span></a></span></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="zh/guide/index.html"><span>Guide</span></a></span><div class="ni n2 "><span class="nh de"><a href="zh/guide/channel_pipeline.html"><span>Channel Pipeline</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="zh/guide/io_model.html"><span>IO Model</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="zh/guide/ioc.html"><span>Actor IOC </span></a></span></div><div class="ni n2 "><span class="nh de"><a href="zh/guide/message_model.html"><span>Message Model</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="zh/guide/reactor_model.html"><span>Reactor Model</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="zh/guide/slf4a.html"><span>SLF4A</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="zh/module/index.html"><span>Modules</span></a></span><div class="ni n2 "><span class="nh de"><a href="zh/module/buffer.html"><span>Buffer</span></a></span></div></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="blog/index.html"><span>Blog</span></a></span><div class="ni n1 "><span class="nh de"><a href="blog/2023/05/19/hello-world-blog.html"><span>hello world blog</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="blog/2023/05/19/hello-world-blog.zh-cn.html"><span>你好世界</span></a></span></div></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/otavia-projects/otavia"><button class="icon-button gh"></button></a><div class="text">Copyright (c) 2022, Yan Kun/Otavia Project</div></div><div class="text-mobile">Copyright (c) 2022, Yan Kun/Otavia Project</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="index.html">otavia</a>/<a href="quick_start.html">Quick Start</a></div><div id="content" class="body-medium"><div><section id="environment-1">
 <h2 class="h500"><a href="#environment-1" class="anchor"></a>Environment</h2>
 <p><img src="https://img.shields.io/badge/JDK-17%2B-blue" alt="Static Badge"> <img src="https://img.shields.io/badge/Scala-3.3%2B-blue" alt="Static Badge"></p>
 <p><code>otavia</code> runs mainly on the JVM platform and currently only supports <code>Scala 3</code> for reliable compile-time type safety. If you are not familiar with <code>Scala 3</code>, you can refer to the following information to learn it.</p>
 <ul>
  <li>Basic(enough for <code>otavia</code>): <a href="https://docs.scala-lang.org/scala3/book/introduction.html">Scala 3 Book</a></li>
  <li>Advance: <a href="https://docs.scala-lang.org/scala3/reference/">Scala 3 Language Reference</a></li>
 </ul>
 <p>The source code for some of the following examples can be found at <a href="https://github.com/otavia-projects/otavia-examples">GitHub - otavia-projects/otavia-examples</a>.</p>
</section>
<section id="add-dependencies-1">
 <h2 class="h500"><a href="#add-dependencies-1" class="anchor"></a>Add dependencies</h2>
 <p>If you use sbt, add the dependency with version <img src="https://img.shields.io/nexus/s/cc.otavia/otavia-runtime_3?server=https%3A%2F%2Fs01.oss.sonatype.org" alt="Sonatype Nexus (Snapshots)"></p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>libraryDependencies += "cc.otavia" %% "otavia-all" % "{version}"
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>If you use mill:</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>ivy"cc.otavia::otavia-all:{version}"
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>if maven:</p>
 <div class="snippet mono-small-block">
  <pre><code class="language-text"><span line-number="1" class=""><span class="tooltip-container"></span>&lt;dependency&gt;
</span><span line-number="2" class=""><span class="tooltip-container"></span>    &lt;groupId&gt;cc.otavia&lt;/groupId&gt;
</span><span line-number="3" class=""><span class="tooltip-container"></span>    &lt;artifactId&gt;otavia-all_3&lt;/artifactId&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>    &lt;version&gt;{version}&lt;/version&gt;
</span><span line-number="5" class=""><span class="tooltip-container"></span>&lt;/dependency&gt;
</span></code></pre>
  <div class="buttons"></div>
 </div>
</section>
<section id="simple-ping-pong-actors-1">
 <h2 class="h500"><a href="#simple-ping-pong-actors-1" class="anchor"></a>Simple Ping-Pong Actors</h2>
 <p>This simple example defines two <code>Actors</code>: <code>PingActor</code> and <code>PongActor</code>, where <code>PingActor</code> receives a <code>Start</code> message and sends a <code>Ping</code> message to <code>PongActor</code>, and each <code>Ping</code> message sent must receive a reply message of type <code>Pong</code>.</p>
</section>
<section id="defining-messages-1">
 <h3 class="h400"><a href="#defining-messages-1" class="anchor"></a>Defining Messages</h3>
 <p>According to the above description, we need 3 types of messages, and these are the 3 basic types of messages in <code>otavia</code>. A <code>Start</code> message is a <code>Notice</code> message, a <code>Notice</code> message is a type of message in <code>otavia</code> that does not need to get a reply, as long as there is an address for the <code>Actor</code> you can send a <code>Notice</code> message to the <code>Actor</code>. <code>Ping</code> is an <code>Ask</code> message that must have a reply message associated with it, so if an <code>Actor</code> sends it to another <code>Actor</code>, it means it must receive a reply message (kind of like a method parameter in a method definition). A <code>Pong</code> is a reply message, which is a bit like a return value in a method definition.</p>
 <p>The <code>Start</code> message is of type <code>Notice</code>, so it must inherit the <code>Notice</code> trait.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Start(sid: Int) extends Notice
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p><code>Pong</code> must inherit the <code>Reply</code> trait, <code>Ping</code> is a message of type <code>Ask</code> and must inherit the <code>Ask</code> trait, the <code>Ask</code> trait carries a type constraint that describes the type of message for which a reply is expected for this <code>Ask</code> message.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Pong(pingId: Int) extends Reply
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>case class Ping(id: Int) extends Ask[Pong]
</span></code></pre>
  <div class="buttons"></div>
 </div>
</section>
<section id="implementing-the-actor-1">
 <h3 class="h400"><a href="#implementing-the-actor-1" class="anchor"></a>Implementing the actor</h3>
 <p>Once we have our messages, let's define our Actor.</p>
 <p>First let's determine the types of messages our <code>Actor</code> can receive, since <code>otavia</code> is a message-type-safe <code>Actor</code> programming framework, so let's determine the types of messages that each <code>Actor</code> can receive: <code>PingActor</code> receives <code>Start</code> and <code>Pong</code> messages, and <code>PongActor</code> receives <code>Ping</code> messages and replies to <code>Pong</code> messages. Since reply messages are constrained by <code>Ask</code> messages in <code>otavia</code>, there is no need to constrain such messages in the definition of <code>Actor</code>, and since <code>PingActor</code> needs to send a message to <code>PongActor</code>, <code>PingActor</code> needs to know the address of <code>PongActor</code>. Roughly, we can define the class name and generic parameters of our Actor as follows:</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PongActor() extends StateActor[Ping] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  // ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>}
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>final class PingActor(pongActorAddress: Address[Ping]) extends StateActor[Start] {
</span><span line-number="6" class=""><span class="tooltip-container"></span>  // ...
</span><span line-number="7" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Here comes <code>StateActor</code> which we can ignore for now, the final <code>Actor</code> in <code>otavia</code> must inherit either <code>StateActor</code> or <code>ChannelsActor</code>. The <code>ChannelsActor</code> is the <code>Actor</code> that handles IO, and all the rest of the <code>Actors</code> are <code>StateActor</code>s.</p>
 <p>Next, let's implement the methods for processing messages!</p>
 <p>First there is the <code>PingActor</code> , which has to process the <code>Start</code> message and send the <code>Ping</code> message during processing, then wait for the <code>Pong</code> message as a reply message, and finally end the processing of the <code>Start</code> message.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PingActor(pongActorAddress: Address[Ping]) extends StateActor[Start] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  override def resumeNotice(stack: NoticeStack[Start]): Option[StackState] = stack.state match {
</span><span line-number="4" class=""><span class="tooltip-container"></span>    case _: StartState =&gt;
</span><span line-number="5" class=""><span class="tooltip-container"></span>      println("PingActor handle Start message")
</span><span line-number="6" class=""><span class="tooltip-container"></span>      println("PingActor send Ping Message")
</span><span line-number="7" class=""><span class="tooltip-container"></span>      val state = FutureState[Pong]()
</span><span line-number="8" class=""><span class="tooltip-container"></span>      pongActorAddress.ask(Ping(stack.notice.sid), state.future)
</span><span line-number="9" class=""><span class="tooltip-container"></span>      state.suspend()
</span><span line-number="10" class=""><span class="tooltip-container"></span>    case state: FutureState[Pong] =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>      val future = state.future
</span><span line-number="12" class=""><span class="tooltip-container"></span>      if (future.isSuccess) {
</span><span line-number="13" class=""><span class="tooltip-container"></span>        println(s"PingActor received ${future.getNow} message success!")
</span><span line-number="14" class=""><span class="tooltip-container"></span>        assert(future.getNow.pingId == stack.ask.sid)
</span><span line-number="15" class=""><span class="tooltip-container"></span>      }
</span><span line-number="16" class=""><span class="tooltip-container"></span>      stack.`return`()
</span><span line-number="17" class=""><span class="tooltip-container"></span>  }
</span><span line-number="18" class=""><span class="tooltip-container"></span>
</span><span line-number="19" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p><code>resumeNotice</code> is the entry point for <code>Actor</code> to process <code>Notice</code> messages. Any <code>Notice</code> messages sent from elsewhere are passed into the <code>Actor</code> through this method. Next we'll implement the <code>PongActor</code>. The <code>PongActor</code> receives a <code>Ping</code> message and replies with a <code>Pong</code> message:</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PongActor() extends StateActor[Ping] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override def resumeAsk(stack: AskStack[Ping]): Option[StackState] = {
</span><span line-number="3" class=""><span class="tooltip-container"></span>    println(s"PongActor received ${stack.ask} message")
</span><span line-number="4" class=""><span class="tooltip-container"></span>    println(s"PongActor reply ${stack.ask} with Pong message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>    stack.`return`(Pong(stack.ask.id))
</span><span line-number="6" class=""><span class="tooltip-container"></span>  }
</span><span line-number="7" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p><code>resumeAsk</code> is the entry point for <code>Actor</code> to process <code>Ask</code> messages, and <code>Ask</code> messages sent from elsewhere are passed into <code>Actor</code> from this method.</p>
 <p>We can see that the <code>resumeXXX</code> method of <code>Actor</code> does not take messages as arguments directly, but rather loads them into <code>Stack</code>s: <code>Notice</code> messages are loaded into <code>NoticeStack</code> and <code>Ask</code> messages are loaded into <code>AskStack</code>. Unlike most other Actor programming frameworks, sending and receiving messages in <code>otavia</code> is tightly managed, which takes away some of the flexibility but ensures that sending and receiving messages are compile-time type-safe, and makes the process of sending and receiving messages more akin to method calls. Let's take a look at how we send and receive messages:</p>
 <ol>
  <li>Sends a <code>Notice</code> message using the <code>notice</code> method of <code>Address</code>. Calling the <code>notice</code> method returns immediately and has no return value.</li>
  <li>Use the <code>Address</code>'s <code>ask</code> method to send an <code>Ask</code> message, and the <code>ask</code> method also takes a <code>Future</code> as an argument. When the <code>Actor</code> receives a <code>Reply</code> message associated with this <code>Ask</code> message, the <code>Reply</code> message is placed into the <code>Future</code> and the state of the <code>Future</code> is set to complete.</li>
  <li>A <code>Future</code> can only be associated with one <code>StackState</code>, but a <code>StackState</code> can be associated with multiple <code>Future</code>s.</li>
  <li>A <code>Stack</code> can only have one <code>StackState</code>. At the end of the <code>resumeXXX</code> method, if the return value is <code>Some(StackState)</code>, set this <code>StackState</code> to the latest state of the <code>Stack</code> and release the old <code>StackState</code> and its associated <code>Future</code>.</li>
  <li>When a <code>Future</code> completes, the <code>StackState</code> checks to see if the associated <code>Stack</code> can be executed again by the <code>resumeXXX</code> method. When the <code>resumable</code> method of <code>StackState</code> returns <code>ture</code> or all associated <code>Future</code>s reach completion, the associated <code>Stack</code> can be executed again.</li>
  <li>The <code>StackState</code> is customizable by the developer and the <code>resumable</code> method can be overridden. Of course, <code>otavia</code> also predefines some common <code>StackState</code>s, such as <code>FutureState</code> used in the example. <code>StackState</code> provides <code>suspend</code> method to return <code>Option[StackState]</code>.</li>
  <li>When the <code>Actor</code> processes a <code>Notice</code> message or an <code>Ask</code> message, it loads the message into a newly created <code>Stack</code>, sets the <code>StackState</code> of the <code>Stack</code> to <code>StackState.start</code>, and passes the <code>Stack</code> to the <code>resumeXXX</code> method to begin execution. . <code>StackState.start</code> is a special <code>StackState</code> of type <code>StartState</code> that is not associated with any <code>Future</code> and whose <code>resumable</code> method returns <code>ture</code>.</li>
  <li>The <code>Stack</code> uses the <code>return</code> method to end processing of the message it is bound to, so the return value of the <code>return</code> method is <code>None</code>. For <code>AskStack</code>, the <code>return</code> method takes a <code>Reply</code> message as an argument to send to the sender of the <code>Ask</code> message as a reply message to the <code>Ask</code> message.</li>
 </ol>
 <p>All of the above is compile-time type-safe for sending and receiving messages! A <code>Stack</code> can only have one <code>StackState</code>, its initial state is <code>StartStack</code>, every time <code>resumeXXX</code> completes, it switches to a new <code>StackState</code>, and the last <code>return</code> method will return <code>None</code>, which means the <code>Stack</code> is complete!</p>
 <p><img src="../images/stack_resume.drawio.svg" alt=""></p>
 <p>Although the message processing may seem complex, most of these steps do not need to be done directly by the developer. The developer implements the <code>resumeXXX</code> method by simply pattern matching the <code>Stack</code>'s <code>StackState</code> and then executing the corresponding business logic. If there is a need to wait for some asynchronous messages, a new <code>StackState</code> is returned, otherwise the <code>return</code> method is used to end the <code>Stack</code>.</p>
 <p>At this point, all the <code>Actors</code> and messages we need are fully implemented. Next, start an <code>ActorSystem</code> to run these <code>Actors</code>.</p>
</section>
<section id="running-the-actor-1">
 <h3 class="h400"><a href="#running-the-actor-1" class="anchor"></a>Running the actor</h3>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>@main def run(): Unit = {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val system = ActorSystem()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val pongActor = system.buildActor(() =&gt; new PongActor())
</span><span line-number="4" class=""><span class="tooltip-container"></span>  val pingActor = system.buildActor(() =&gt; new PingActor(pongActor))
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  pingActor.notice(Start(88))
</span><span line-number="7" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>With <code>ActorSystem()</code> we can easily create an <code>ActorSystem</code>, which is a runtime container for the actor in <code>otavia</code>. A JVM instance is only allowed to start one <code>ActorSystem</code> instance. The <code>buildActor</code> method of <code>ActorSystem</code> allows us to instantiate our <code>Actor</code>. The <code>buildActor</code> method does not return the <code>Actor</code> object itself, instead it returns an <code>Address</code> to which we can send messages that the <code>Actor</code> can handle.</p>
 <p>Everything above is compile-time type-safe; if you send a message to the address returned by <code>buildActor</code> that the corresponding actor can't handle, it won't compile. Same, if you use the <code>AskStack</code>'s <code>return</code> method to send a <code>Reply</code> message that does not match the corresponding <code>Ask</code> message, this will also fail to compile.</p>
</section>
<section id="receive-multiple-message-types-1">
 <h2 class="h500"><a href="#receive-multiple-message-types-1" class="anchor"></a>Receive multiple message types</h2>
 <p>The above example demonstrates an actor that handles one type of message, but in real-world scenarios we often need to handle multiple types of messages in a single actor. This is very easy in <code>Scala 3</code>, and thanks to <code>Scala 3</code>'s powerful <code>Union Types</code> and <code>Intersection Types</code>, we can also make it compile-time type-safe to handle multiple messages.</p>
 <p>Suppose we need to implement an actor that receives a <code>Hello</code> message and returns a <code>World</code> message, receives a <code>Ping</code> message and returns a <code>Pong</code> message, and receives an <code>Echo</code> message and returns no message.</p>
 <p>The above requirement requires us to define the following kinds of messages:</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Echo() extends Notice
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>case class World() extends Reply
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>case class Hello() extends Ask[World]
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>case class Pong() extends Reply
</span><span line-number="8" class=""><span class="tooltip-container"></span>
</span><span line-number="9" class=""><span class="tooltip-container"></span>case class Ping() extends Ask[Pong]
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Then we implement our actor:</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class MultiMsgActor() extends StateActor[Echo | Hello | Ping] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  override def resumeNotice(stack: NoticeStack[Echo]): Option[StackState] = {
</span><span line-number="4" class=""><span class="tooltip-container"></span>    println("MultiMsgActor received Echo message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>    stack.`return`()
</span><span line-number="6" class=""><span class="tooltip-container"></span>  }
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>  override def resumeAsk(stack: AskStack[Hello | Ping]): Option[StackState] = {
</span><span line-number="9" class=""><span class="tooltip-container"></span>    stack match {
</span><span line-number="10" class=""><span class="tooltip-container"></span>      case stack: AskStack[Hello] if stack.ask.isInstanceOf[Hello] =&gt; handleHello(stack)
</span><span line-number="11" class=""><span class="tooltip-container"></span>      case stack: AskStack[Ping] if stack.ask.isInstanceOf[Ping] =&gt; handlePing(stack)
</span><span line-number="12" class=""><span class="tooltip-container"></span>    }
</span><span line-number="13" class=""><span class="tooltip-container"></span>  }
</span><span line-number="14" class=""><span class="tooltip-container"></span>
</span><span line-number="15" class=""><span class="tooltip-container"></span>  private def handleHello(stack: AskStack[Hello]): Option[StackState] = {
</span><span line-number="16" class=""><span class="tooltip-container"></span>    println("MultiMsgActor received Hello message")
</span><span line-number="17" class=""><span class="tooltip-container"></span>    stack.`return`(World())
</span><span line-number="18" class=""><span class="tooltip-container"></span>  }
</span><span line-number="19" class=""><span class="tooltip-container"></span>
</span><span line-number="20" class=""><span class="tooltip-container"></span>  private def handlePing(stack: AskStack[Ping]): Option[StackState] = {
</span><span line-number="21" class=""><span class="tooltip-container"></span>    println("MultiMsgActor received Ping message")
</span><span line-number="22" class=""><span class="tooltip-container"></span>    stack.`return`(Pong())
</span><span line-number="23" class=""><span class="tooltip-container"></span>  }
</span><span line-number="24" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>You might wonder, if a message inherits both <code>Notice</code> and <code>Ask</code>, will the message end up being processed by <code>resumeNotice</code> or <code>resumeAsk</code>? The answer is both. <code>Otavia</code> does not determine how a message should be handled based on the type of message, but by how it is sent. There are <code>notice</code> and <code>ask</code> methods in <code>Address</code>, and messages sent by the <code>notice</code> method are eventually processed by <code>resumeNotice</code>, while messages sent by the <code>ask</code> method are processed by <code>resumeAsk</code>!</p>
</section>
<section id="timer-3">
 <h2 class="h500"><a href="#timer-3" class="anchor"></a>Timer</h2>
 <p>The <code>otavia</code> runtime includes a powerful timer component, <code>Timer</code>, which you can interact with in a number of ways, the main usage scenarios are described below:</p>
</section>
<section id="handle-timeoutevent-1">
 <h3 class="h400"><a href="#handle-timeoutevent-1" class="anchor"></a>Handle TimeoutEvent</h3>
 <p>An <code>Actor</code> can register for a timeout trigger task via the <code>registerActorTimeout</code> method of <code>Timer</code>. When the timeout condition is reached, the <code>Timer</code> generates a <code>TimeoutEvent</code> and sends it to the registered <code>Actor</code>. The timeout event is then handled by the <code>handleActorTimeout</code> method of the <code>Actor</code>.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class TickActor() extends StateActor[Nothing] { // [Nothing] if no message need process!
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  private var onceTickId: Long = Timer.INVALID_TIMEOUT_REGISTER_ID
</span><span line-number="4" class=""><span class="tooltip-container"></span>  private var periodTickId: Long = Timer.INVALID_TIMEOUT_REGISTER_ID
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  override protected def afterMount(): Unit = {
</span><span line-number="7" class=""><span class="tooltip-container"></span>    onceTickId = timer.registerActorTimeout(TimeoutTrigger.DelayTime(1, TimeUnit.SECONDS), self)
</span><span line-number="8" class=""><span class="tooltip-container"></span>    periodTickId = timer.registerActorTimeout(TimeoutTrigger.DelayPeriod(2, 2, TimeUnit.SECONDS, TimeUnit.SECONDS), self)
</span><span line-number="9" class=""><span class="tooltip-container"></span>  }
</span><span line-number="10" class=""><span class="tooltip-container"></span>
</span><span line-number="11" class=""><span class="tooltip-container"></span>  override protected def handleActorTimeout(timeoutEvent: TimeoutEvent): Unit = {
</span><span line-number="12" class=""><span class="tooltip-container"></span>    if (timeoutEvent.registerId == periodTickId) {
</span><span line-number="13" class=""><span class="tooltip-container"></span>      println(s"period timeout event triggered at ${LocalDateTime.now()}")
</span><span line-number="14" class=""><span class="tooltip-container"></span>    } else if (timeoutEvent.registerId == onceTickId) {
</span><span line-number="15" class=""><span class="tooltip-container"></span>      println(s"once timeout event triggered at ${LocalDateTime.now()}")
</span><span line-number="16" class=""><span class="tooltip-container"></span>    } else {
</span><span line-number="17" class=""><span class="tooltip-container"></span>      println("Never run this")
</span><span line-number="18" class=""><span class="tooltip-container"></span>    }
</span><span line-number="19" class=""><span class="tooltip-container"></span>  }
</span><span line-number="20" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>It is important to note that the <code>timer</code> method within the <code>Actor</code> object must be used after the <code>Actor</code> has been mounted on the <code>ActorSystem</code>. Only after the <code>Actor</code> has been mounted will runtime-related information be injected into the <code>Actor</code> object. Therefore, you cannot use the <code>timer</code> method directly in the constructor of the <code>Actor</code> object because the <code>Actor</code> instance has not been mounted to the <code>ActorSystem</code> yet, and using the runtime-related methods will result in a null pointer exception. This is described later in the <code>Actor</code> lifecycle.</p>
</section>
<section id="stack-sleep-2">
 <h3 class="h400"><a href="#stack-sleep-2" class="anchor"></a>Stack Sleep</h3>
 <p>If we want a <code>Stack</code> to wait a certain amount of time before it starts re-executing, we can have <code>StackState</code> associated with a <code>MessageFuture[TimeoutReply]</code> , and this <code>Future</code> will take the timeout event as a result. The <code>MessageFuture[TimeoutReply]</code> completes only when the timeout event is received.</p>
 <p>In the previous example, <code>PingActor</code> handles the <code>Start</code> message with <code>FutureState</code> , which is one of the more common state classes defined by <code>otavia</code>, but you can also customize <code>StackState</code> if these don't meet your needs.</p>
 <p>Now <code>FutureState</code> is not enough for us because it is bound to only one <code>MessageFuture[Pong]</code>, now we need to bind not only <code>MessageFuture[Pong]</code> but also <code>MessageFuture[TimeoutReply]</code>. <code>Stack</code> can be re-executed only when both <code>Future</code>s have completed. Let's define our new <code>StackState</code>.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class PongTimeoutState extends StackState {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val pongFuture = MessageFuture[Pong]()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val timeoutFuture = MessageFuture[TimeoutReply]()
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Next, re-implement our <code>PingActor</code></p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PingActor(pongActorAddress: Address[Ping]) extends StateActor[Start] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override def resumeNotice(stack: NoticeStack[Start]): Option[StackState] = stack.state match {
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case _: StartState =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>      println("PingActor handle Start message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>      println("PingActor send Ping Message")
</span><span line-number="6" class=""><span class="tooltip-container"></span>      val state = PongTimeoutState()
</span><span line-number="7" class=""><span class="tooltip-container"></span>      pongActorAddress.ask(Ping(stack.notice.sid), state.pongFuture)
</span><span line-number="8" class=""><span class="tooltip-container"></span>      timer.sleepStack(state.timeoutFuture, 2 * 1000)
</span><span line-number="9" class=""><span class="tooltip-container"></span>      state.suspend()
</span><span line-number="10" class=""><span class="tooltip-container"></span>    case state: PongTimeoutState =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>      val future = state.pongFuture
</span><span line-number="12" class=""><span class="tooltip-container"></span>      if (future.isSuccess) {
</span><span line-number="13" class=""><span class="tooltip-container"></span>        println(s"PingActor received ${future.getNow} message success!")
</span><span line-number="14" class=""><span class="tooltip-container"></span>        assert(future.getNow.pingId == stack.ask.sid)
</span><span line-number="15" class=""><span class="tooltip-container"></span>      }
</span><span line-number="16" class=""><span class="tooltip-container"></span>      stack.`return`()
</span><span line-number="17" class=""><span class="tooltip-container"></span>  }
</span><span line-number="18" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Okay, that's done! Now our <code>PingActor</code> needs to receive the <code>Pong</code> reply message and also wait 2 seconds for this <code>Stack</code> to be resumed.</p>
</section>
<section id="setting-a-timeout-for-reply-messages-1">
 <h3 class="h400"><a href="#setting-a-timeout-for-reply-messages-1" class="anchor"></a>Setting a Timeout for Reply Messages</h3>
 <p>Sometimes, when we send an <code>Ask</code> message, the <code>Actor</code> on the other side may take a long time, but we don't want our requesting <code>Actor</code> to wait too long, what do we do in this case? Maybe you've already figured out the answer! We've talked about this before:</p>
 <blockquote>
  <p>A <code>StackState</code> can be associated with one or more <code>Future</code>s , and a <code>Stack</code> can only resume execution if the <code>resumable</code> method of the <code>StackState</code> is <code>ture</code>, or all associated <code>Future</code>s have reached completion.</p>
 </blockquote>
 <p>So we can override the <code>resumable</code> method of <code>StackState</code>! Now let's redefine our <code>PongTimeoutState</code> method.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class PongTimeoutState extends StackState {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val pongFuture = MessageFuture[Pong]()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val timeoutFuture = MessageFuture[TimeoutReply]()
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>  override def resumable(): Boolean = timeoutFuture.isDone
</span><span line-number="6" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Now as soon as <code>timeoutFuture</code> completes, then <code>Stack</code> can be re-executed. However, when we use <code>pongFuture</code> we need to check for completion with <code>pongFuture.isDone</code>. That's one way to do it, but given that this is a relatively common scenario, <code>otavia</code> provides a simpler way. All we need to do is make a small change to our previous implementation of <code>PingActor</code>:</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PingActor(pongActorAddress: Address[Ping]) extends StateActor[Start] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override def resumeNotice(stack: NoticeStack[Start]): Option[StackState] = stack.state match {
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case _: StartState =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>      println("PingActor handle Start message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>      println("PingActor send Ping Message")
</span><span line-number="6" class=""><span class="tooltip-container"></span>      val state = FutureState()
</span><span line-number="7" class=""><span class="tooltip-container"></span>      pongActorAddress.ask(Ping(stack.notice.sid), state.future, 2 * 1000)
</span><span line-number="8" class=""><span class="tooltip-container"></span>      state.suspend()
</span><span line-number="9" class=""><span class="tooltip-container"></span>    case state: FutureState[Pong] =&gt;
</span><span line-number="10" class=""><span class="tooltip-container"></span>      val future = state.future
</span><span line-number="11" class=""><span class="tooltip-container"></span>      if (future.isSuccess) {
</span><span line-number="12" class=""><span class="tooltip-container"></span>        println(s"PingActor received ${future.getNow} message success!")
</span><span line-number="13" class=""><span class="tooltip-container"></span>        assert(future.getNow.pingId == stack.ask.sid)
</span><span line-number="14" class=""><span class="tooltip-container"></span>      }
</span><span line-number="15" class=""><span class="tooltip-container"></span>      stack.`return`()
</span><span line-number="16" class=""><span class="tooltip-container"></span>  }
</span><span line-number="17" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Notice the difference! The <code>ask</code> method comes with a timeout parameter!</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>pongActorAddress.ask(Ping(stack.notice.sid), state.future, 2 * 1000) // new 
</span><span line-number="2" class=""><span class="tooltip-container"></span>pongActorAddress.ask(Ping(stack.notice.sid), state.future) // old
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>If the <code>Pong</code> message is not received after 2 seconds, then the <code>Future</code> will be set to complete, but unlike before, we can't get the <code>Pong</code> message from inside the <code>Future</code>, it's already in a failed state, i.e. <code>isDone=ture isSuccess=false isFailed= ture</code>. Since this <code>StackState</code> is associated with only one <code>Future</code>, and this <code>Future</code> is already in a completed state, this <code>Stack</code> can continue to be scheduled for execution.</p>
</section>
<section id="lifecycle-of-actor-1">
 <h2 class="h500"><a href="#lifecycle-of-actor-1" class="anchor"></a>LifeCycle of Actor</h2>
 <p>In <code>otavia</code>, the user doesn't have to worry much about managing the life cycle of <code>Actor</code>, the <code>Actor</code> instance is still managed by the JVM garbage collection. As long as the <code>Actor</code> is no longer referenced by the GC root object, the <code>Actor</code> instance will be automatically reclaimed by the JVM's garbage collection system. There are several hook methods in <code>Actor</code> that can be called during different life cycles, such as</p>
 <ul>
  <li><code>afterMount</code>: Called after the <code>Actor</code> instance is mounted to <code>ActorSystem</code> <strong>For Actor instances <code>context</code> related methods are only available after mounting</strong>.</li>
  <li><code>beforeRestart</code>: Called before reboot.</li>
  <li><code>restart</code>: Methods for restarting <code>Actor</code> instances.</li>
  <li><code>afterRestart</code>: Called after a reboot.</li>
  <li><code>AutoCleanable.cleaner</code>: If your implementation of <code>Actor</code> needs to clean up some unsafe resources, inherit the <code>AutoCleanable</code> trait and implement the <code>cleaner</code> method.</li>
 </ul>
 <p>The following figure shows the complete lifecycle of an <code>Actor</code>:</p>
 <p><img src="../images/actor_life_cycle.drawio.svg" alt=""></p>
 <p>Let's define an <code>Actor</code> and look at the various hook methods in the lifecycle:</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Start() extends Notice
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>final class LifeActor extends StateActor[Start] with AutoCleanable {
</span><span line-number="4" class=""><span class="tooltip-container"></span>  override protected def afterMount(): Unit = println("LifeActor: afterMount")
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  override protected def beforeRestart(): Unit = println("LifeActor: beforeRestart")
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>  override protected def restart(): Unit = println("LifeActor: restart")
</span><span line-number="9" class=""><span class="tooltip-container"></span>
</span><span line-number="10" class=""><span class="tooltip-container"></span>  override protected def afterRestart(): Unit = println("LifeActor: afterRestart")
</span><span line-number="11" class=""><span class="tooltip-container"></span>
</span><span line-number="12" class=""><span class="tooltip-container"></span>  override def cleaner(): ActorCleaner = new ActorCleaner {
</span><span line-number="13" class=""><span class="tooltip-container"></span>
</span><span line-number="14" class=""><span class="tooltip-container"></span>    println("creating actor cleaner")
</span><span line-number="15" class=""><span class="tooltip-container"></span>
</span><span line-number="16" class=""><span class="tooltip-container"></span>    override protected def clean(): Unit = println("clean actor resource before actor stop")
</span><span line-number="17" class=""><span class="tooltip-container"></span>
</span><span line-number="18" class=""><span class="tooltip-container"></span>  }
</span><span line-number="19" class=""><span class="tooltip-container"></span>
</span><span line-number="20" class=""><span class="tooltip-container"></span>  // if occurs some error which developer is not catch, this will trigger the actor restart
</span><span line-number="21" class=""><span class="tooltip-container"></span>  // you can also override the noticeExceptionStrategy method to change the strategy
</span><span line-number="22" class=""><span class="tooltip-container"></span>  override def resumeNotice(stack: NoticeStack[Start]): Option[StackState] = {
</span><span line-number="23" class=""><span class="tooltip-container"></span>    println("process message")
</span><span line-number="24" class=""><span class="tooltip-container"></span>    throw new Error("")
</span><span line-number="25" class=""><span class="tooltip-container"></span>  }
</span><span line-number="26" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>The <code>afterMount</code> method is mainly used for dependency injection, which will be explained in more detail later.</p>
</section>
<section id="handling-io-1">
 <h2 class="h500"><a href="#handling-io-1" class="anchor"></a>Handling IO</h2>
 <p>Now we have learned to 1) Define <code>Actor</code> 2) Define messages 3) Send a message 4) Receive a message and process a message 5) Trigger a timeout using <code>Timer</code>.</p>
 <p>But in real business, we often need to deal with a lot of IO tasks, and IO tasks will block our threads, which is one of the reasons why our programs are underperforming. At the same time, some new technologies such as epoll, io_uring, etc. are booming, which allow us to handle IO tasks without blocking. The JVM also provides NIO to support non-blocking IO, but it's not easy to use NIO because the APIs provided by the JVM, such as <code>java.nio.ByteBuffer</code> and <code>java.nio.channels.Channel</code>, are too low-level. It's more common to use Netty to handle IO tasks in the JVM.</p>
 <p>Thanks to Netty for providing a powerful IO programming tool for the JVM world! Inspired by Netty, the IO module in <code>otavia</code> is basically ported from <code>Netty</code>! Handling IO tasks in <code>otavia</code> is very much the same as in Netty, and the API is basically the same. This also makes it very easy for <code>otavia</code> to take advantage of the extensive Netty ecosystem and port codecs for various network protocols. <a href="https://github.com/otavia-projects">View otavia ecosystem</a>.</p>
 <p><img src="../images/two_types_actor.drawio.svg" alt=""></p>
 <p><code>otavia</code> also uses <code>Channel</code> to represent an IO object, such as an open file, a network connection. In <code>otavia</code>, however, the <code>Channel</code> must run in a <code>ChannelsActor</code>. Also <code>Channel</code> contains a <code>ChannelPipeline</code> component with a <code>ChannelHandler</code> queue.</p>
 <p><img src="../images/pipeline.drawio.svg" alt=""></p>
 <p>In order to better manage different <code>Channel</code>s, <code>otavia</code> implements several different kinds of <code>ChannelsActor</code>, they are:</p>
 <ul>
  <li><code>AcceptorActor</code>: manages the <code>Channel</code> that listens for TCP connections, which needs to instantiate a set of <code>AcceptedWorkerActor</code>s as working <code>Actor</code>s. Normal <code>Channel</code>s that are accepted by the listening <code>Channel</code> are wrapped in a message and sent to one of the <code>AcceptedWorkerActor</code>s, and managed by the selected <code>AcceptedWorkerActor</code>.</li>
  <li><code>AcceptedWorkerActor</code>: The working <code>Actor</code> for the <code>AcceptorActor</code>.</li>
  <li><code>SocketChannelsActor</code>: manages the TCP client <code>Channel</code>.</li>
  <li><code>DatagramChannelsActor</code>: manages the UDP <code>Channel</code>.</li>
 </ul>
 <p>You will need to choose a type of <code>ChannelsActor</code> to implement depending on your needs. Now, let's start our journey with a simple file reading example!</p>
</section>
<section id="files-io-1">
 <h3 class="h400"><a href="#files-io-1" class="anchor"></a>Files IO</h3>
 <p>Netty only supports network IO, <code>otavia</code> supports not only network but also files. Now we're going to implement an <code>Actor</code> that receives a request to read a file and returns the file as a <code>Seq[String]</code>.</p>
 <p>First, let's define the messages that this <code>Actor</code> needs to process and return.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class LinesReply(lines: Seq[String]) extends Reply
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>case class ReadLines() extends Ask[LinesReply]
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Next we will implement our <code>Actor</code>, what is the behavior of this <code>Actor</code>? First we need to open the file! So we have a <code>Channel</code> that represents the file, and we send the command to read the file to this <code>Channel</code>.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class ReadLinesActor(file: File, charset: Charset = StandardCharsets.UTF_8)
</span><span line-number="2" class=""><span class="tooltip-container"></span>  extends ChannelsActor[ReadLines] {
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>  override protected def initFileChannel(channel: Channel): Unit = ???
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  override def resumeAsk(stack: AskStack[ReadLines]): Option[StackState] = {
</span><span line-number="7" class=""><span class="tooltip-container"></span>    stack.state match {
</span><span line-number="8" class=""><span class="tooltip-container"></span>      case StackState.start =&gt;
</span><span line-number="9" class=""><span class="tooltip-container"></span>        openFileChannelAndSuspend(file, Seq(StandardOpenOption.READ), attrs = Seq.empty)
</span><span line-number="10" class=""><span class="tooltip-container"></span>      case openState: ChannelFutureState if openState.id == 0 =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>        val linesState = ChannelFutureState(1)
</span><span line-number="12" class=""><span class="tooltip-container"></span>        openState.future.channel.ask(FileReadPlan(-1, -1), linesState.future)
</span><span line-number="13" class=""><span class="tooltip-container"></span>        linesState.suspend()
</span><span line-number="14" class=""><span class="tooltip-container"></span>      case linesState: ChannelFutureState if linesState.id == 1 =&gt;
</span><span line-number="15" class=""><span class="tooltip-container"></span>        stack.`return`(LinesReply(linesState.future.getNow.asInstanceOf[Seq[String]]))
</span><span line-number="16" class=""><span class="tooltip-container"></span>    }
</span><span line-number="17" class=""><span class="tooltip-container"></span>  }
</span><span line-number="18" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>First we use the <code>openFileChannelAndSuspend</code> method to open the file and return a <code>StackState</code>, which will be ready to run when the file is opened. This method is a shortcut provided by the <code>ChannelsActor</code>, and we can see from the source code that it is implemented as:</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// source code from ChannelsActor
</span><span line-number="2" class=""><span class="tooltip-container"></span>val channel = createFileChannelAndInit()
</span><span line-number="3" class=""><span class="tooltip-container"></span>val state = ChannelFutureState()
</span><span line-number="4" class=""><span class="tooltip-container"></span>val future: ChannelFuture = state.future
</span><span line-number="5" class=""><span class="tooltip-container"></span>channel.open(path, opts, attrs, future)
</span><span line-number="6" class=""><span class="tooltip-container"></span>state.suspend().asInstanceOf[Option[ChannelFutureState]]
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Nothing special, it's pretty much the same as the <code>Stack</code> we talked about before, except that here the <code>StackState</code> is a <code>ChannelFutureState</code> and the associated <code>Future</code> is a <code>ChannelFuture</code>. This <code>ChannelFuture</code> is then passed to <code>Channel</code> using the <code>channel.open</code> method. The <code>open</code> method is not blocking and returns immediately after it is called, and if this file is opened, then <code>Reactor</code> sends <code>ChannelsActor</code> a <code>ReactorEvent</code>, <code>ChannelsActor</code> receives the event and sets the <code>ChannelFuture</code> to completion. The <code>ChannelActor</code> then checks to see if the <code>Stack</code> associated with it can be re-executed.</p>
 <p>Here we also see a <code>createFileChannelAndInit</code> method, which we can guess from the name creates a file <code>Channel</code> and also initializes the <code>Channel</code>. This method calls the <code>ChannelsActor.initFileChannel</code> method to initialize the <code>Channel</code>.</p>
 <p>Now we can implement our <code>ReadLinesActor.initFileChannel</code>. We can see that we passed in a <code>FileReadPlan</code> instance after the file was opened:</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val linesState = ChannelFutureState(1)
</span><span line-number="2" class=""><span class="tooltip-container"></span>openState.future.channel.ask(FileReadPlan(-1, -1), linesState.future)
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>The <code>ask</code> method will eventually pass <code>FileReadPlan</code> into <code>ChannelPipeline</code> via the <code>write</code> method of <code>Channel</code>. The <code>ChannelHandler</code> inside the <code>ChannelPipeline</code> needs to be implemented by us, which is basically the same as in Netty.</p>
 <p>Now let's implement our <code>ChannelHandler</code>. What does this <code>ChannelHandler</code> need to do? First, we need to be able to handle the <code>write</code> inbound event, and second, we need to handle the <code>channelRead</code> outbound event. Then we need to handle the <code>channelReadComplete</code> outbound event when the read is complete, and in the <code>channelReadComplete</code> method, we need to generate the final result message back to our <code>ReadLinesActor</code>.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class ReadLinesHandler(charset: Charset) extends ByteToMessageDecoder {
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  private val lines = ArrayBuffer.empty[String]
</span><span line-number="4" class=""><span class="tooltip-container"></span>  private var currentMsgId: Long = -1
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  override def write(ctx: ChannelHandlerContext, msg: AnyRef, msgId: Long): Unit = msg match {
</span><span line-number="7" class=""><span class="tooltip-container"></span>    case readPlan: FileReadPlan =&gt;
</span><span line-number="8" class=""><span class="tooltip-container"></span>      ctx.read(readPlan)
</span><span line-number="9" class=""><span class="tooltip-container"></span>      currentMsgId = msgId
</span><span line-number="10" class=""><span class="tooltip-container"></span>    case _ =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>      ctx.write(msg, msgId)
</span><span line-number="12" class=""><span class="tooltip-container"></span>  }
</span><span line-number="13" class=""><span class="tooltip-container"></span>
</span><span line-number="14" class=""><span class="tooltip-container"></span>  override protected def decode(ctx: ChannelHandlerContext, input: AdaptiveBuffer): Unit = {
</span><span line-number="15" class=""><span class="tooltip-container"></span>    var continue = true
</span><span line-number="16" class=""><span class="tooltip-container"></span>    while (continue) {
</span><span line-number="17" class=""><span class="tooltip-container"></span>      val length = input.bytesBefore('\n'.toByte) + 1
</span><span line-number="18" class=""><span class="tooltip-container"></span>      if (length &gt; 0) {
</span><span line-number="19" class=""><span class="tooltip-container"></span>        lines.addOne(input.readCharSequence(length, charset).toString)
</span><span line-number="20" class=""><span class="tooltip-container"></span>      } else continue = false
</span><span line-number="21" class=""><span class="tooltip-container"></span>    }
</span><span line-number="22" class=""><span class="tooltip-container"></span>  }
</span><span line-number="23" class=""><span class="tooltip-container"></span>
</span><span line-number="24" class=""><span class="tooltip-container"></span>  override def channelReadComplete(ctx: ChannelHandlerContext): Unit = {
</span><span line-number="25" class=""><span class="tooltip-container"></span>    val seq = lines.toSeq
</span><span line-number="26" class=""><span class="tooltip-container"></span>    lines.clear()
</span><span line-number="27" class=""><span class="tooltip-container"></span>    val msgId = currentMsgId
</span><span line-number="28" class=""><span class="tooltip-container"></span>    currentMsgId = -1
</span><span line-number="29" class=""><span class="tooltip-container"></span>    ctx.fireChannelRead(seq, msgId)
</span><span line-number="30" class=""><span class="tooltip-container"></span>  }
</span><span line-number="31" class=""><span class="tooltip-container"></span>
</span><span line-number="32" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Then we also need to add this <code>ReadLinesHandler</code> to the <code>ChannelPipeline</code> of our <code>Channel</code>, remember the <code>initFileChannel</code> method that we didn't implement in the <code>ReadLinesActor</code> before. Now we can finalize this method!</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>override protected def initFileChannel(channel: Channel): Unit =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  channel.pipeline.addFirst(new ReadLinesHandler(charset))
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>We can notice that our <code>write</code> method has a <code>msgId</code> parameter, which is a unique message number within the <code>Channel</code> generated by the <code>ask</code> method. Because the <code>write</code> method is non-blocking, it does not wait for the underlying IO call to complete, but instead submits a command to read the data to the <code>Reactor</code> via <code>ChannelHandlerContext.read</code>. The actual IO work of reading the data is done by the <code>Reactor</code>, and the result is sent to the <code>ChannelsActor</code> as an <code>Event</code>. The <code>ChannelsActor</code> then dispatches the <code>Event</code> to the <code>Channel</code>. The <code>Channel</code> then propagates a corresponding outbound event in the <code>ChannelPipeline</code> by calling the <code>channelRead</code> method. Here we inherit from <code>ByteToMessageDecoder</code>, whose <code>channelRead</code> method calls the <code>decode</code> method, which is mainly used to convert a sequence of bytes into the object we need. When the <code>Reactor</code> finishes reading the data, it also sends an <code>Event</code> to the <code>ChannelsActor</code>, which in turn calls the <code>channelReadComplete</code> method to propagate an outbound event in the <code>ChannelPipeline</code>. We need to override the <code>channelReadComplete</code> method in our <code>ReadLinesHandler</code> to generate the final result and continue to call the <code>channelRead</code> method to propagate the final result in the outbound direction. Notice that our <code>fireChannelRead</code> method also has a <code>msgId</code> parameter that will allow the message to eventually find its way to the <code>Future</code> inside our previous <code>ask</code> method. Next the story goes back to our <code>Actor</code>'s <code>Stack</code> dispatch.</p>
 <p>Now let's start our program to read a text file!</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>@main def start(): Unit = {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val system = ActorSystem()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val readLinesActor = system.buildActor(() =&gt; new ReadLinesActor("build.sc"))
</span><span line-number="4" class=""><span class="tooltip-container"></span>  system.buildActor(() =&gt; new MainActor(Array.empty) {
</span><span line-number="5" class=""><span class="tooltip-container"></span>    override def main0(stack: NoticeStack[MainActor.Args]): Option[StackState] = stack.state match {
</span><span line-number="6" class=""><span class="tooltip-container"></span>      case _: StartState =&gt;
</span><span line-number="7" class=""><span class="tooltip-container"></span>        val state = FutureState[LinesReply]()
</span><span line-number="8" class=""><span class="tooltip-container"></span>        readLinesActor.ask(ReadLines(), state.future)
</span><span line-number="9" class=""><span class="tooltip-container"></span>        state.suspend()
</span><span line-number="10" class=""><span class="tooltip-container"></span>      case state: FutureState[LinesReply] =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>        for (line &lt;- state.future.getNow.lines) print(line)
</span><span line-number="12" class=""><span class="tooltip-container"></span>        stack.`return`()
</span><span line-number="13" class=""><span class="tooltip-container"></span>    }
</span><span line-number="14" class=""><span class="tooltip-container"></span>  })
</span><span line-number="15" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>You may be thinking that this is too much trouble, I can just use the java file API to do it in a few lines of code, but you have to write so much! Well, you have to pay for what you get, and the payoff is that this file IO doesn't block the current <code>Actor</code>'s execution thread! The actual IO reading and writing in <code>otavia</code> is done by the <code>Reactor</code> component, whose default transport layer implementation is based on NIO. Since the transport layer is implemented using the SPI mechanism, we can replace the default NIO transport layer with a higher-performance one based on techniques such as epoll, kqueue, IOCP, or even io_uring! This doesn't require a single change to the upper level code, as long as you implement the transport layer module according to the SPI specification, add the JARs to CLASSPATH, and it will take effect immediately! Implementing this efficient transport layer module is the goal of the <a href="https://github.com/otavia-projects/native-transport">native-transport</a> project in <a href="https://github.com/otavia-projects">otavia ecosystem</a>! If you are interested, your contributions are warmly welcomed!</p>
</section>
<section id="network-io-1">
 <h3 class="h400"><a href="#network-io-1" class="anchor"></a>Network IO</h3>
 <p>Now we are going to implement an echo server on a TCP network that can use telnet to connect, send data inside the telnet, and return the data to the telnet as is. Since this is a TCP service, we use <code>AcceptedWorkerActor</code> and <code>AcceptorActor</code> to implement it. The classes we implement named <code>EchoAcceptor</code> and <code>EchoWorker</code>.</p>
 <p>First we implement <code>EchoAcceptor</code>, this <code>Actor</code> manages a <code>Channel</code> that listens for connections, accepts the connection and generates a new <code>Channel</code>, and then sends this new <code>Channel</code> to the <code>EchoWorker</code>. The <code>EchoWorker</code> is responsible for specific tasks.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class EchoAcceptor extends AcceptorActor[EchoWorker] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override protected def workerNumber: Int = 4
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>  override protected def workerFactory: AcceptorActor.WorkerFactory[EchoServerWorker] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>    () =&gt; new EchoWorker()
</span><span line-number="6" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>In <code>EchoAcceptor</code> we define the <code>workerFactory</code> method of how to create an <code>EchoWorker</code> and the <code>workerNumber</code> method of how many <code>EchoWorker</code> instances to create. The <code>EchoAcceptor</code> receives the <code>ChannelsActor.Bind</code> message and then creates a <code>Channel</code> and binds it to a port to listen for network connections. A <code>WorkerNumber</code> instance of <code>EchoWorker</code> is created to distribute the incoming network connections. Next we define our <code>EchoWorker</code></p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class EchoWorker extends AcceptedWorkerActor[Nothing] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  override protected def initChannel(channel: Channel): Unit = ???
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>  override def resumeAsk(stack: AskStack[AcceptedChannel]): Option[StackState] =
</span><span line-number="6" class=""><span class="tooltip-container"></span>    handleAccepted(stack)
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>  override protected def afterAccepted(channel: ChannelAddress): Unit =
</span><span line-number="9" class=""><span class="tooltip-container"></span>    println(s"EchoWorker accepted ${channel}")
</span><span line-number="10" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Notice the <code>initChannel</code> method? It's similar to <code>initFileChannel</code> in the previous example, but this method is used to initialize the network <code>Channel</code>. We need to define our <code>ChannelHandler</code> again and add it to the <code>ChannelPipeline</code> via this method. Now let's implement our <code>ChannelHandler</code>.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class EchoWorkerHandler extends ByteToMessageDecoder {
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  override protected def decode(ctx: ChannelHandlerContext, input: AdaptiveBuffer): Unit =
</span><span line-number="4" class=""><span class="tooltip-container"></span>    if (input.readableBytes &gt; 0) ctx.writeAndFlush(input)
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Now that we have our <code>EchoWorkerHandler</code>, let's add it to <code>ChannelPipeline</code>:</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>override protected def initChannel(channel: Channel): Unit =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  channel.pipeline.addLast(new EchoWorkerHandler())
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Now that everything is ready, let's start our echo server!</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>@main def start(): Unit = {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val actorSystem = ActorSystem()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  actorSystem.buildActor(() =&gt; new MainActor() {
</span><span line-number="4" class=""><span class="tooltip-container"></span>    override def main0(stack: NoticeStack[MainActor.Args]): Option[StackState] = stack.state match {
</span><span line-number="5" class=""><span class="tooltip-container"></span>      case _: StartState =&gt;
</span><span line-number="6" class=""><span class="tooltip-container"></span>        val acceptor = system.buildActor(() =&gt; new EchoAcceptor())
</span><span line-number="7" class=""><span class="tooltip-container"></span>        val state = FutureState[BindReply]()
</span><span line-number="8" class=""><span class="tooltip-container"></span>        acceptor.ask(Bind(8080), state.future)
</span><span line-number="9" class=""><span class="tooltip-container"></span>        state.suspend()
</span><span line-number="10" class=""><span class="tooltip-container"></span>      case state: FutureState[BindReply] =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>        println("echo server bind port 8080 success")
</span><span line-number="12" class=""><span class="tooltip-container"></span>        stack.`return`()
</span><span line-number="13" class=""><span class="tooltip-container"></span>    }
</span><span line-number="14" class=""><span class="tooltip-container"></span>  })
</span><span line-number="15" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Just start telnet and connect to the echo server and try it out!</p>
 <blockquote>
  <p>This example is just a brief introduction to the use of Channel, and does not show the more powerful ways in which Channel can interact with the ChannelsActor. You can learn more at <a href="core_concept.html#channel">Core Concepts and Design</a>.</p>
 </blockquote>
</section>
<section id="global-actor-and-dependency-injection-1">
 <h2 class="h500"><a href="#global-actor-and-dependency-injection-1" class="anchor"></a>Global Actor and Dependency Injection</h2>
 <p>Dependency injection is an effective way to decouple code, and it's also useful for the Actor model. Imagine that sometimes our <code>Actor</code> can receive a fixed type of message, but we have different implementations for different scenarios. If we use <code>buildActor</code> to construct these <code>Actors</code>, there is significant code coupling. Whenever the scenario changes we need to modify this code, which is very inflexible. To solve this problem, <code>otavia</code> introduces the idea of dependency injection. We will use a simple example to demonstrate how dependency injection works in <code>otavia</code>.</p>
 <p>Let's assume that we need to rely on a service <code>Actor</code> in our system, and we know the type of messages it receives and returns, but this service requires different implementations in different scenarios. The following is the message definition for our service.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Result1() extends Reply
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>case class Query1() extends Ask[Result1]
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>case class Result2() extends Reply
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>case class Query2() extends Ask[Result2]
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>We can then define a <code>trait</code> to constrain the messages that our service <code>Actor</code> can receive. This is similar to defining a service using interfaces in object-oriented, except that in object-oriented you use interfaces to constrain the methods that can be called and in <code>otavia</code> you use interfaces to constrain the messages that can be processed!</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait QueryService extends Actor[Query1 | Query2]
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>With this <code>QueryService</code> interface, the specific service <code>Actor</code> we implement needs to inherit from this interface.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class QueryServiceImpl() extends StateActor with QueryService {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override def resumeAsk(stack: AskStack[Query1 | Query2]): Option[StackState] = ??? // impl logic
</span><span line-number="3" class=""><span class="tooltip-container"></span>}
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>// QueryService in another scenario
</span><span line-number="6" class=""><span class="tooltip-container"></span>final class QueryServiceCase2() extends SocketChannelsActor with QueryService {
</span><span line-number="7" class=""><span class="tooltip-container"></span>  override def resumeAsk(stack: AskStack[Query1 | Query2]): Option[StackState] = ??? // impl logic
</span><span line-number="8" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>For <code>Actor</code>s that rely on <code>QueryService</code>, you can use the <code>autowire</code> method to look up the <code>Address</code> of an available <code>QueryService</code> in the <code>ActorSystem</code>.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Start() extends Notice
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>final class TestActor extends StateActor[Start] {
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>  private var queryService: Address[MessageOf[QueryService]] = _
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>  override protected def afterMount(): Unit = queryService = autowire[QueryService]() // compile-time type-safe
</span><span line-number="8" class=""><span class="tooltip-container"></span>
</span><span line-number="9" class=""><span class="tooltip-container"></span>  override def resumeNotice(stack: NoticeStack[Start]): Option[StackState] = stack.state match {
</span><span line-number="10" class=""><span class="tooltip-container"></span>    case StackState.start =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>      val state = FutureState[Result1]()
</span><span line-number="12" class=""><span class="tooltip-container"></span>      queryService.ask(Query1(), state.future)
</span><span line-number="13" class=""><span class="tooltip-container"></span>      state.suspend()
</span><span line-number="14" class=""><span class="tooltip-container"></span>    case state: FutureState[?] =&gt;
</span><span line-number="15" class=""><span class="tooltip-container"></span>      val pong = state.future.asInstanceOf[MessageFuture[Result1]].getNow
</span><span line-number="16" class=""><span class="tooltip-container"></span>      stack.`return`()
</span><span line-number="17" class=""><span class="tooltip-container"></span>  }
</span><span line-number="18" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Now even if we replace the implementation of <code>QueryService</code>, our <code>TestActor</code> doesn't have to change at all! How do we get <code>autowire[QueryService]()</code> to find the specific implementation <code>Actor</code>, just set it to the global <code>Actor</code> when instantiating the implementation <code>Actor</code>.</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>system.buildActor(() =&gt; new QueryServiceImpl(), global = true)
</span><span line-number="2" class=""><span class="tooltip-container"></span>// or if use the other one
</span><span line-number="3" class=""><span class="tooltip-container"></span>system.buildActor(() =&gt; new QueryServiceCase2(), global = true)
</span></code></pre>
  <div class="buttons"></div>
 </div>
</section>
<section id="batch-processing-messages-1">
 <h2 class="h500"><a href="#batch-processing-messages-1" class="anchor"></a>Batch Processing Messages</h2>
 <p>Being able to batch messages is a useful technique for some scenarios. Allowing batching is simple, you just need to override the <code>batchable</code> method of your <code>Actor</code> to change its return value to <code>true</code>, and then override the <code>batchNoticeFilter</code> or <code>batchAskFilter</code> methods to select the messages that will go into the batch schedule.</p>
 <p>For the detailed code you can refer <a href="https://github.com/otavia-projects/otavia/blob/main/log4a/src/cc/otavia/log4a/appender/ConsoleAppender.scala">ConsoleAppender</a></p>
</section></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#environment-1">Environment</a></li><li><a href="#add-dependencies-1">Add dependencies</a></li><li><a href="#simple-ping-pong-actors-1">Simple Ping-Pong Actors</a><ul><li><a href="#defining-messages-1">Defining Messages</a></li><li><a href="#implementing-the-actor-1">Implementing the actor</a></li><li><a href="#running-the-actor-1">Running the actor</a></li></ul></li><li><a href="#receive-multiple-message-types-1">Receive multiple message types</a></li><li><a href="#timer-3">Timer</a><ul><li><a href="#handle-timeoutevent-1">Handle TimeoutEvent</a></li><li><a href="#stack-sleep-2">Stack Sleep</a></li><li><a href="#setting-a-timeout-for-reply-messages-1">Setting a Timeout for Reply Messages</a></li></ul></li><li><a href="#lifecycle-of-actor-1">LifeCycle of Actor</a></li><li><a href="#handling-io-1">Handling IO</a><ul><li><a href="#files-io-1">Files IO</a></li><li><a href="#network-io-1">Network IO</a></li></ul></li><li><a href="#global-actor-and-dependency-injection-1">Global Actor and Dependency Injection</a></li><li><a href="#batch-processing-messages-1">Batch Processing Messages</a></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/otavia-projects/otavia"><button class="icon-button gh"></button></a><div class="text">Copyright (c) 2022, Yan Kun/Otavia Project</div></div><div class="text-mobile">Copyright (c) 2022, Yan Kun/Otavia Project</div></div></div></div></body></html>