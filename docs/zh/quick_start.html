<!DOCTYPE html><html data-pathToRoot="../../"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>快速开始</title><link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico"></link><script type="text/javascript" src="../../scripts/theme.js"></script><script type="text/javascript" src="../../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../../styles/theme/bundle.css"></link><link rel="stylesheet" href="../../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../../styles/nord-light.css"></link><link rel="stylesheet" href="../../styles/dotty-icons.css"></link><link rel="stylesheet" href="../../styles/filter-bar.css"></link><link rel="stylesheet" href="../../styles/code-snippets.css"></link><link rel="stylesheet" href="../../styles/searchbar.css"></link><link rel="stylesheet" href="../../styles/social-links.css"></link><link rel="stylesheet" href="../../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../../styles/content-contributors.css"></link><link rel="stylesheet" href="../../styles/fontawesome.css"></link><script type="text/javascript" src="../../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../../styles/staticsitestyles.css"></link><script>var pathToRoot = "../../";</script><meta charset="utf-8">
<title>Hello, world!</title></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../../home.html" class="logo-container"><span class="project-name h300">otavia</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">0.3.8-SNAPSHOT</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span class="project-name h300">otavia</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="../index.html">Docs</a><a id="api-nav-button" class="switcher h100 " href="../../index.html">API</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0 "><span class="nh de"><a href="../name_from.html"><span>Name From</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="../quick_start.html"><span>Quick Start</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="../core_concept.html"><span>Core Concepts and Design</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../guide/index.html"><span>Guide</span></a></span><div class="ni n1 "><span class="nh de"><a href="../guide/actor_model.html"><span>Actor Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/channel_pipeline.html"><span>Channel Pipeline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/io_model.html"><span>IO Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/ioc.html"><span>Actor IOC </span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/message_model.html"><span>Message Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/reactor_model.html"><span>Reactor Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/slf4a.html"><span>SLF4A</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/serde.html"><span>Serde framework</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../module/index.html"><span>Modules</span></a></span><div class="ni n1 "><span class="nh de"><a href="../module/buffer.html"><span>Buffer</span></a></span></div></div><div class="ni n0 expanded"><span class="nh h100 expanded cs de"><button class="ar icon-button expanded"></button><a href="index.html"><span>中文文档</span></a></span><div class="ni n1 "><span class="nh de"><a href="name_from.html"><span>名称来源</span></a></span></div><div class="ni n1 expanded"><span class="nh h100 selected de"><a href="#"><span>快速开始</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="core_concept.html"><span>核心概念与设计</span></a></span></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="guide/index.html"><span>Guide</span></a></span><div class="ni n2 "><span class="nh de"><a href="guide/channel_pipeline.html"><span>Channel Pipeline</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="guide/io_model.html"><span>IO Model</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="guide/ioc.html"><span>Actor IOC </span></a></span></div><div class="ni n2 "><span class="nh de"><a href="guide/message_model.html"><span>Message Model</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="guide/reactor_model.html"><span>Reactor Model</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="guide/slf4a.html"><span>SLF4A</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="module/index.html"><span>Modules</span></a></span><div class="ni n2 "><span class="nh de"><a href="module/buffer.html"><span>Buffer</span></a></span></div></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../blog/index.html"><span>Blog</span></a></span><div class="ni n1 "><span class="nh de"><a href="../blog/2023/05/19/hello-world-blog.html"><span>hello world blog</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../blog/2023/05/19/hello-world-blog.zh-cn.html"><span>你好世界</span></a></span></div></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/otavia-projects/otavia"><button class="icon-button gh"></button></a><div class="text">Copyright (c) 2022, Yan Kun/Otavia Project</div></div><div class="text-mobile">Copyright (c) 2022, Yan Kun/Otavia Project</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">otavia</a>/<a href="index.html">中文文档</a>/<a href="quick_start.html">快速开始</a></div><div id="content" class="body-medium"><div><section id="环境要求-1">
 <h2 class="h500"><a href="#环境要求-1" class="anchor"></a>环境要求</h2>
 <p><img src="https://img.shields.io/badge/JDK-17%2B-blue" alt="Static Badge"> <img src="https://img.shields.io/badge/Scala-3.3%2B-blue" alt="Static Badge"></p>
 <p><code>otavia</code> 虽然主要运行在JVM平台上，但是为了保证可靠的编译时类型安全，目前只支持 <code>Scala 3</code>, 如果您对 <code>Scala 3</code> 不是很熟悉，您可以参考以下资料进行学习。</p>
 <ul>
  <li>基础知识（对于学习 <code>otavia</code> 足够了）: <a href="https://docs.scala-lang.org/zh-cn/scala3/book/introduction.html">Scala 3 Book</a></li>
  <li>高级知识：<a href="https://docs.scala-lang.org/scala3/reference/">Scala 3 Language Reference</a></li>
 </ul>
 <p>以下部分示例的源码可以在 <a href="https://github.com/otavia-projects/otavia-examples">otavia-examples</a> 中找到。</p>
</section>
<section id="添加依赖-1">
 <h2 class="h500"><a href="#添加依赖-1" class="anchor"></a>添加依赖</h2>
 <p>如果您使用 sbt , 请添加以下依赖，其中 version = <img src="https://img.shields.io/nexus/s/cc.otavia/otavia-runtime_3?server=https%3A%2F%2Fs01.oss.sonatype.org" alt="Sonatype Nexus (Snapshots)"></p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>libraryDependencies += "cc.otavia" %% "otavia-all" % "{version}"
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>如果您使用 mill：</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>ivy"cc.otavia::otavia-all:{version}"
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>如果使用 maven:</p>
 <div class="snippet mono-small-block">
  <pre><code class="language-text"><span line-number="1" class=""><span class="tooltip-container"></span>&lt;dependency&gt;
</span><span line-number="2" class=""><span class="tooltip-container"></span>    &lt;groupId&gt;cc.otavia&lt;/groupId&gt;
</span><span line-number="3" class=""><span class="tooltip-container"></span>    &lt;artifactId&gt;otavia-all_3&lt;/artifactId&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>    &lt;version&gt;{version}&lt;/version&gt;
</span><span line-number="5" class=""><span class="tooltip-container"></span>&lt;/dependency&gt;
</span></code></pre>
  <div class="buttons"></div>
 </div>
</section>
<section id="简单的-ping-pong-actors-1">
 <h2 class="h500"><a href="#简单的-ping-pong-actors-1" class="anchor"></a>简单的 Ping-Pong Actors</h2>
 <p>这个简单的示例定义了两个 <code>Actor</code>: <code>PingActor</code> 和 <code>PongActor</code>, <code>PingActor</code> 接收 <code>Start</code> 消息，然后向 <code>PongActor</code> 发送 <code>Ping</code> 消息， 每个发送的 <code>Ping</code> 消息都必须接收一个 <code>Pong</code> 类型的回复消息。</p>
</section>
<section id="定义消息-1">
 <h3 class="h400"><a href="#定义消息-1" class="anchor"></a>定义消息</h3>
 <p>根据以上描述，我们需要3种消息，而这也正是 <code>otavia</code> 3种基本的消息类型。<code>Start</code> 消息是一种 <code>Notice</code> 消息， <code>Notice</code> 消息是 <code>otavia</code> 中一种不需要获得回复的消息，只要有 <code>Actor</code> 的地址， 您就可以向 <code>Actor</code> 发送 <code>Notice</code> 消息；<code>Ping</code> 是一种 <code>Ask</code> 消息，这种消息必须关联一种回复消息，如果一个 <code>Actor</code> 向 其他 <code>Actor</code> 发送了这种消息，就意味着其必须收到一个回复消息（有点像方法定义中的方法参数）；<code>Pong</code> 是一种回复消息， 回复消息有点像方法定义中的返回值。</p>
 <p><code>Start</code> 消息是 <code>Notice</code> 类型，所以必须继承 <code>Notice</code> trait</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Start(sid: Int) extends Notice
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p><code>Pong</code> 必须继承 <code>Reply</code> trait, <code>Ping</code> 是 <code>Ask</code> 类型的消息，所以必须继承 <code>Ask</code> trait。 <code>Ask</code> trait 带有一个类型约束， 用来描述这个 <code>Ask</code> 消息期望获得的回复的消息类型。</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Pong(pingId: Int) extends Reply
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>case class Ping(id: Int) extends Ask[Pong]
</span></code></pre>
  <div class="buttons"></div>
 </div>
</section>
<section id="实现-actor-1">
 <h3 class="h400"><a href="#实现-actor-1" class="anchor"></a>实现 Actor</h3>
 <p>有了消息之后，我们来定义我们的 <code>Actor</code>。</p>
 <p>首先我们确定我们的 <code>Actor</code> 能接收的消息类型，因为 <code>otavia</code> 是一种消息类型安全的 <code>Actor</code> 编程框架，所以我们先来确定每种 <code>Actor</code> 能接收的消息类型： <code>PingActor</code> 能接收 <code>Start</code> 消息和 <code>Pong</code> 消息，<code>PongActor</code> 接收 <code>Ping</code> 消息并且回复 <code>Pong</code> 消息。因为在 <code>otavia</code> 中回复消息通过 <code>Ask</code> 消息进行约束，所以在 <code>Actor</code> 的定义中就不需要对这种消息进行约束，由 于 <code>PingActor</code> 需要给 <code>PongActor</code> 发送消息，所以 <code>PingActor</code> 需要知道 <code>PongActor</code> 的地址。 大概能定义出我们 的 <code>Actor</code> 的类及泛型参数如下：</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PongActor() extends StateActor[Ping] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  // ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>}
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>final class PingActor(pongActorAddress: Address[Ping]) extends StateActor[Start] {
</span><span line-number="6" class=""><span class="tooltip-container"></span>  // ...
</span><span line-number="7" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>这里出现了 <code>StateActor</code> 我们暂时可以先不用管，<code>otavia</code> 中的最终 <code>Actor</code> 必须继承 <code>StateActor</code> 或 <code>ChannelsActor</code>， <code>ChannelsActor</code> 是用于处理 IO 的 <code>Actor</code> , 其余所有的 <code>Actor</code> 都是 <code>StateActor</code>。</p>
 <p>接下来让我们来实现具体的消息处理吧！</p>
 <p>首先是 <code>PingActor</code> , 他需要处理 <code>Start</code> 消息，并且处理过程中需要发送 <code>Ping</code> 消息，然后等待 <code>Pong</code> 回复消息，最后结束 <code>Start</code> 消息的处理。</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PingActor(pongActorAddress: Address[Ping]) extends StateActor[Start] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  override def resumeNotice(stack: NoticeStack[Start]): Option[StackState] = stack.state match {
</span><span line-number="4" class=""><span class="tooltip-container"></span>    case _: StartState =&gt;
</span><span line-number="5" class=""><span class="tooltip-container"></span>      println("PingActor handle Start message")
</span><span line-number="6" class=""><span class="tooltip-container"></span>      println("PingActor send Ping Message")
</span><span line-number="7" class=""><span class="tooltip-container"></span>      val state = FutureState[Pong]()
</span><span line-number="8" class=""><span class="tooltip-container"></span>      pongActorAddress.ask(Ping(stack.notice.sid), state.future)
</span><span line-number="9" class=""><span class="tooltip-container"></span>      stack.suspend(state)  
</span><span line-number="10" class=""><span class="tooltip-container"></span>    case state: FutureState[Pong] =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>      val future = state.future
</span><span line-number="12" class=""><span class="tooltip-container"></span>      if (future.isSuccess) {
</span><span line-number="13" class=""><span class="tooltip-container"></span>        println(s"PingActor received ${future.getNow} message success!")
</span><span line-number="14" class=""><span class="tooltip-container"></span>        assert(future.getNow.pingId == stack.ask.sid)
</span><span line-number="15" class=""><span class="tooltip-container"></span>      }
</span><span line-number="16" class=""><span class="tooltip-container"></span>      stack.`return`()
</span><span line-number="17" class=""><span class="tooltip-container"></span>  }
</span><span line-number="18" class=""><span class="tooltip-container"></span>
</span><span line-number="19" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p><code>resumeNotice</code> 是 <code>Actor</code> 处理 <code>Notice</code> 消息的入口，从其他地方发送来的 <code>Notice</code> 消息都会通过这个方法传入 <code>Actor</code>, 接下来我们来实现 <code>PongActor</code>, <code>PongActor</code> 接收 <code>Ping</code> 这种 <code>Ask</code> 消息，然后回复一个 <code>Pong</code> 消息：</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PongActor() extends StateActor[Ping] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override def resumeAsk(stack: AskStack[Ping]): Option[StackState] = {
</span><span line-number="3" class=""><span class="tooltip-container"></span>    println(s"PongActor received ${stack.ask} message")
</span><span line-number="4" class=""><span class="tooltip-container"></span>    println(s"PongActor reply ${stack.ask} with Pong message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>    stack.`return`(Pong(stack.ask.id))
</span><span line-number="6" class=""><span class="tooltip-container"></span>  }
</span><span line-number="7" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p><code>resumeAsk</code> 是 <code>Actor</code> 处理 <code>Ask</code> 消息的入口。从其他 <code>Actor</code> 发送来的 <code>Ask</code> 消息都会从这个方法传入 <code>Actor</code>。</p>
 <p>我们可以发现， <code>Actor</code> 的 <code>resumeXXX</code> 方法并不是直接将消息作为参数，而是将消息装入 <code>Stack</code> 中一起作为参数：<code>Notice</code> 消息装入 <code>NoticeStack</code> 中，<code>Ask</code> 消息装入 <code>AskStack</code> 中。 与大多数其他 Actor 编程框架不一样，<code>otavia</code> 中消息的发送和接收都被严格的管理， 这虽然丧失了一部分灵活性，但是却保证了发送消息和接收消息的编译时类型安全，并且让发送消息和接收消息的过程更加类似于方法的调用。我们来看看 我们是怎么样发送消息和接收消息的吧：</p>
 <ol>
  <li>使用 <code>Address</code> 的 <code>notice</code> 方法发送 <code>Notice</code> 消息，调用 <code>notice</code> 方法会立即返回。<code>notice</code> 方法没有返回值。</li>
  <li>使用 <code>Address</code> 的 <code>ask</code> 方法发送 <code>Ask</code> 消息，同时 <code>ask</code> 方法需要传入一个 <code>Future</code>。当 <code>Actor</code> 接收到与这个 <code>Ask</code> 消息关联的 <code>Reply</code> 消息的时候，这个 <code>Reply</code> 消息就会被放入 <code>Future</code> 中，同时 <code>Future</code> 的状态会被设置为完成。</li>
  <li><code>Future</code> 只能关联到一个 <code>StackState</code>，但是 <code>StackState</code> 可以关联多个 <code>Future</code>。</li>
  <li>一个 <code>Stack</code> 只能拥有一个 <code>StackState</code>。当 <code>resumeXXX</code> 方法结束时，如果返回值为 <code>Some(StackState)</code>， 就将这个 <code>StackState</code> 设置为 <code>Stack</code> 的当前状态，同时释放老的 <code>StackState</code> 及其关联的 <code>Future</code>。</li>
  <li><code>Future</code> 完成的时候会通过 <code>StackState</code> 检查与其关联的 <code>Stack</code> 是否可以再次被 <code>resumeXXX</code> 方法执行。当 <code>StackState</code> 的 <code>resumable</code> 方法返回 <code>ture</code> 或者关联的所有的 <code>Future</code> 都达到完成状态的时候与其关联的 <code>Stack</code> 就可以再次被执行。</li>
  <li><code>StackState</code> 由开发者自定义，<code>resumable</code> 方法可以被重写。当然 <code>otavia</code> 预定义了一些常用的 <code>StackState</code>，比如示例中 使用的 <code>FutureState</code>。<code>StackState</code> 提供了 <code>suspend</code> 方法返回 <code>Option[StackState]</code>。</li>
  <li>当 <code>Actor</code> 处理 <code>Notice</code> 消息或者 <code>Ask</code> 消息的时候，就将消息装入一个新建的 <code>Stack</code> 中，并且将 <code>Stack</code> 的 <code>StackState</code> 设置为一个特殊的值 <code>StackState.start</code>，然后将 <code>Stack</code> 传递给 <code>resumeXXX</code> 方法开始执行。 <code>StackState.start</code> 是一个类型为 <code>StartState</code> 的特殊 <code>StackState</code>，其不关联任何 <code>Future</code> 并且 <code>resumable</code> 方 法返回 <code>ture</code>。</li>
  <li><code>Stack</code> 使用 <code>return</code> 方法结束与其绑定消息的处理，所以 <code>return</code> 方法返回值为 <code>None</code>。对于 <code>AskStack</code>，<code>return</code> 需要一个 <code>Reply</code> 消息作为参数发送给 <code>Ask</code> 消息的发送者作为 <code>Ask</code> 消息的回复消息。</li>
 </ol>
 <p>以上一切消息的发送和接收都是编译时类型安全的！一个 <code>Stack</code> 只能有一个 <code>StackState</code>，其初始的状态为 <code>StartStack</code>， 每次 <code>resumeXXX</code> 执行完成就切换到一个新的 <code>StackState</code>, 最后的 <code>return</code> 方法将返回 <code>None</code>，代表 <code>Stack</code> 完成！</p>
 <p><img src="../../images/stack_resume.drawio.svg" alt=""></p>
 <p>虽然上诉过程看起来比较复杂，但是这些步骤大多数都不需要开发者直接完成。开发者实现 <code>resumeXXX</code> 方法的时候，只需要对 <code>Stack</code> 的 <code>StackState</code> 进行模式匹配 ，然后执行对应的业务逻辑。如果有需要等待异步消息，就返回一个新的 <code>StackState</code> ，否则使用 <code>return</code> 方法结束 <code>Stack</code>。</p>
 <p>至此，我们需要的所有的 <code>Actor</code> 和消息都已经完全实现了。接下来，启动一个 <code>ActorSystem</code> 来运行这些 <code>Actor</code> 吧</p>
</section>
<section id="运行-actor-1">
 <h3 class="h400"><a href="#运行-actor-1" class="anchor"></a>运行 Actor</h3>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>@main def run(): Unit = {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val system = ActorSystem()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val pongActor = system.buildActor(() =&gt; new PongActor())
</span><span line-number="4" class=""><span class="tooltip-container"></span>  val pingActor = system.buildActor(() =&gt; new PingActor(pongActor))
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  pingActor.notice(Start(88))
</span><span line-number="7" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>通过 <code>ActorSystem()</code> 我们就可以轻松创建一个 <code>ActorSystem</code>, <code>ActorSystem</code> 是 <code>otavia</code> 中 <code>Actor</code> 的运行时容器， 一个 JVM 实例只允许启动一个 <code>ActorSystem</code> 实例。通过 <code>ActorSystem</code> 的 <code>buildActor</code> 方法，我们可以实例化我们定义的 <code>Actor</code> ， <code>buildActor</code> 方法并不会返回 <code>Actor</code> 实例对象本身，相反他返回的是一个代表 <code>Actor</code> 的地址，我们可以通过这个 地址发送 <code>Actor</code> 能处理的消息。</p>
 <p>以上的一切都是编译时类型安全的，如果您向 <code>buildActor</code> 返回的地址发送 <code>Actor</code> 不能处理的消息，这将不能通过编译。如果您使用 <code>AskStack</code> 的 <code>return</code> 方法返回与 <code>Ask</code> 消息不匹配的 <code>Reply</code> 消息，这也将不能通过编译。</p>
</section>
<section id="接收多种类型消息的-actor-1">
 <h2 class="h500"><a href="#接收多种类型消息的-actor-1" class="anchor"></a>接收多种类型消息的 Actor</h2>
 <p>以上的示例演示了处理一种消息类型的 <code>Actor</code>， 但是在真实的场景中我们往往需要在一个 <code>Actor</code> 中处理多种类型的消息。这在 <code>Scala 3</code> 中非常简单，而且由于 <code>Scala 3</code> 强大的 <code>Union Types</code> 和 <code>Intersection Types</code>，我们还可以做到处理多种 消息的编译时类型安全。</p>
 <p>假如我们需要实现一个 <code>Actor</code>， 这个 <code>Actor</code> 的行为为：接收 <code>Hello</code> 消息并且返回 <code>World</code> 消息， 接收 <code>Ping</code> 消息并且 返回 <code>Pong</code> 消息， 接收 <code>Echo</code> 消息不返回任何消息。那么我们可以先定义消息的类型：</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Echo() extends Notice
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>case class World() extends Reply
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>case class Hello() extends Ask[World]
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>case class Pong() extends Reply
</span><span line-number="8" class=""><span class="tooltip-container"></span>
</span><span line-number="9" class=""><span class="tooltip-container"></span>case class Ping() extends Ask[Pong]
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>然后来实现我们的 <code>Actor</code>：</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class MultiMsgActor() extends StateActor[Echo | Hello | Ping] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  override def resumeNotice(stack: NoticeStack[Echo]): Option[StackState] = {
</span><span line-number="4" class=""><span class="tooltip-container"></span>    println("MultiMsgActor received Echo message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>    stack.`return`()
</span><span line-number="6" class=""><span class="tooltip-container"></span>  }
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>  override def resumeAsk(stack: AskStack[Hello | Ping]): Option[StackState] = {
</span><span line-number="9" class=""><span class="tooltip-container"></span>    stack match {
</span><span line-number="10" class=""><span class="tooltip-container"></span>      case stack: AskStack[Hello] if stack.ask.isInstanceOf[Hello] =&gt; handleHello(stack)
</span><span line-number="11" class=""><span class="tooltip-container"></span>      case stack: AskStack[Ping] if stack.ask.isInstanceOf[Ping] =&gt; handlePing(stack)
</span><span line-number="12" class=""><span class="tooltip-container"></span>    }
</span><span line-number="13" class=""><span class="tooltip-container"></span>  }
</span><span line-number="14" class=""><span class="tooltip-container"></span>
</span><span line-number="15" class=""><span class="tooltip-container"></span>  private def handleHello(stack: AskStack[Hello]): Option[StackState] = {
</span><span line-number="16" class=""><span class="tooltip-container"></span>    println("MultiMsgActor received Hello message")
</span><span line-number="17" class=""><span class="tooltip-container"></span>    stack.`return`(World())
</span><span line-number="18" class=""><span class="tooltip-container"></span>  }
</span><span line-number="19" class=""><span class="tooltip-container"></span>
</span><span line-number="20" class=""><span class="tooltip-container"></span>  private def handlePing(stack: AskStack[Ping]): Option[StackState] = {
</span><span line-number="21" class=""><span class="tooltip-container"></span>    println("MultiMsgActor received Ping message")
</span><span line-number="22" class=""><span class="tooltip-container"></span>    stack.`return`(Pong())
</span><span line-number="23" class=""><span class="tooltip-container"></span>  }
</span><span line-number="24" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>你可能会想，要是一个消息同时继承了 <code>Notice</code> 和 <code>Ask</code>，这个消息最终是被 <code>resumeNotice</code> 还是 <code>resumeAsk</code> 处理呢？ 答案是都有可能。<code>otavia</code> 不是根据消息的种类来决定其应该被怎么处理，而是通过消息的发送方式。<code>Address</code> 中有 <code>notice</code> 和 <code>ask</code> 方法，以 <code>notice</code> 方法发送的消息最终被 <code>resumeNotice</code> 处理， <code>ask</code> 方法发送的消息被 <code>resumeAsk</code> 处理！</p>
</section>
<section id="计时-1">
 <h2 class="h500"><a href="#计时-1" class="anchor"></a>计时</h2>
 <p><code>otavia</code> 运行时包含了一个强大的计时器组件 <code>Timer</code> ，您可以使用多种方式与 <code>Timer</code> 进行交互，以下将介绍主要的使用场景：</p>
</section>
<section id="处理注册的定时事件-1">
 <h3 class="h400"><a href="#处理注册的定时事件-1" class="anchor"></a>处理注册的定时事件</h3>
 <p><code>Actor</code> 可以通过 <code>Timer</code> 的 <code>registerActorTimeout</code> 方法注册一个超时事件触发任务。当达到超时条件时，<code>Timer</code> 会生成一个 <code>TimeoutEvent</code> 并且发送给注册的 <code>Actor</code>。然后超时事件会通过 <code>Actor</code> 的 <code>handleActorTimeout</code> 方法进行处理。</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class TickActor() extends StateActor[Nothing] { // [Nothing] if no message need process!
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  private var onceTickId: Long = Timer.INVALID_TIMEOUT_REGISTER_ID
</span><span line-number="4" class=""><span class="tooltip-container"></span>  private var periodTickId: Long = Timer.INVALID_TIMEOUT_REGISTER_ID
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  override protected def afterMount(): Unit = {
</span><span line-number="7" class=""><span class="tooltip-container"></span>    onceTickId = timer.registerActorTimeout(TimeoutTrigger.DelayTime(1, TimeUnit.SECONDS), self)
</span><span line-number="8" class=""><span class="tooltip-container"></span>    periodTickId = timer.registerActorTimeout(TimeoutTrigger.DelayPeriod(2, 2, TimeUnit.SECONDS, TimeUnit.SECONDS), self)
</span><span line-number="9" class=""><span class="tooltip-container"></span>  }
</span><span line-number="10" class=""><span class="tooltip-container"></span>
</span><span line-number="11" class=""><span class="tooltip-container"></span>  override protected def handleActorTimeout(timeoutEvent: TimeoutEvent): Unit = {
</span><span line-number="12" class=""><span class="tooltip-container"></span>    if (timeoutEvent.registerId == periodTickId) {
</span><span line-number="13" class=""><span class="tooltip-container"></span>      println(s"period timeout event triggered at ${LocalDateTime.now()}")
</span><span line-number="14" class=""><span class="tooltip-container"></span>    } else if (timeoutEvent.registerId == onceTickId) {
</span><span line-number="15" class=""><span class="tooltip-container"></span>      println(s"once timeout event triggered at ${LocalDateTime.now()}")
</span><span line-number="16" class=""><span class="tooltip-container"></span>    } else {
</span><span line-number="17" class=""><span class="tooltip-container"></span>      println("Never run this")
</span><span line-number="18" class=""><span class="tooltip-container"></span>    }
</span><span line-number="19" class=""><span class="tooltip-container"></span>  }
</span><span line-number="20" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>值得注意的是 <code>Actor</code> 对象内 <code>timer</code> 方法的使用必须在 <code>Actor</code> 挂载到 <code>ActorSystem</code> 之后，只有挂载之后，运行时相关的信息才 会被注入到 <code>Actor</code> 实例内。所以您不能在 <code>Actor</code> 对象的构造器内直接使用 <code>timer</code> 方法，因为这个时候 <code>Actor</code> 实例还没有挂载 到 <code>ActorSystem</code> 中，使用运行时相关的方法都会导致空指针异常。这在后文的 <code>Actor</code> 生命周期中有介绍。</p>
</section>
<section id="stack-sleep-3">
 <h3 class="h400"><a href="#stack-sleep-3" class="anchor"></a>Stack Sleep</h3>
 <p>如果我们想让一个 <code>Stack</code> 等待一段时间才开始执行，我们可以让 <code>StackState</code> 关联到一个 <code>MessageFuture[TimeoutReply]</code> , 这个 <code>Future</code> 会将超时事件作为结果。只有收到超时事件的时候，<code>MessageFuture[TimeoutReply]</code> 才完成。</p>
 <p>在之前的示例中，<code>PingActor</code> 处理 <code>Start</code> 消息的时候使用了 <code>FutureState</code> , 这是 <code>otavia</code> 定义的一些比较常用的状态类，如果 这些状态类不能满足您的需要，您也可以自定义 <code>StackState</code>。</p>
 <p>让我们改造一下之前的 <code>PingActor</code>，现在我们要求这个 <code>Actor</code> 收到 <code>Start</code> 消息之后发送 <code>Ping</code> 请求，然后收到 <code>Pong</code> 消息 的时候还需要等待2秒才能继续调度这个 <code>NoticeStack</code> 执行。</p>
 <p>现在 <code>FutureState</code> 已经不能满足我们的需求了，因为其只绑定了一个 <code>MessageFuture[Pong]</code>, 现在我们不仅需要绑定 <code>MessageFuture[Pong]</code>，还需要绑定 <code>MessageFuture[TimeoutReply]</code>，只有这两个 <code>Future</code> 都完成的时候才开始执行这个 <code>Stack</code>。让我们来定义我们新的 <code>StackState</code> 吧。</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class PongTimeoutState extends StackState {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val pongFuture = MessageFuture[Pong]()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val timeoutFuture = MessageFuture[TimeoutReply]()
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>接下来，重新实现我们的 <code>PingActor</code></p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PingActor(pongActorAddress: Address[Ping]) extends StateActor[Start] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override def resumeNotice(stack: NoticeStack[Start]): Option[StackState] = stack.state match {
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case _: StartState =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>      println("PingActor handle Start message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>      println("PingActor send Ping Message")
</span><span line-number="6" class=""><span class="tooltip-container"></span>      val state = PongTimeoutState()
</span><span line-number="7" class=""><span class="tooltip-container"></span>      pongActorAddress.ask(Ping(stack.notice.sid), state.pongFuture)
</span><span line-number="8" class=""><span class="tooltip-container"></span>      timer.sleepStack(state.timeoutFuture, 2 * 1000)
</span><span line-number="9" class=""><span class="tooltip-container"></span>      stack.suspend(state)  
</span><span line-number="10" class=""><span class="tooltip-container"></span>    case state: PongTimeoutState =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>      val future = state.pongFuture
</span><span line-number="12" class=""><span class="tooltip-container"></span>      if (future.isSuccess) {
</span><span line-number="13" class=""><span class="tooltip-container"></span>        println(s"PingActor received ${future.getNow} message success!")
</span><span line-number="14" class=""><span class="tooltip-container"></span>        assert(future.getNow.pingId == stack.ask.sid)
</span><span line-number="15" class=""><span class="tooltip-container"></span>      }
</span><span line-number="16" class=""><span class="tooltip-container"></span>      stack.`return`()
</span><span line-number="17" class=""><span class="tooltip-container"></span>  }
</span><span line-number="18" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>好了，完成了！现在我们的 <code>PingActor</code> 即使收到 <code>Pong</code> 回复消息，也要等待2秒这个 <code>Stack</code> 才会被继续调度执行。</p>
</section>
<section id="给-reply-消息设置超时-1">
 <h3 class="h400"><a href="#给-reply-消息设置超时-1" class="anchor"></a>给 Reply 消息设置超时</h3>
 <p>有时候，当我们发送一个 <code>Ask</code> 消息，对面的 <code>Actor</code> 可能会耗时比较久，但是我们不想让我们的请求 <code>Actor</code> 等待太久，这种情况我们 怎么办呢？也许聪明的您已经想到答案了！之前我们讲过：</p>
 <blockquote>
  <p>一个 <code>StackState</code> 可以关联一个或者多个 <code>Future</code> , 只有当 <code>StackState</code> 的 <code>resumable</code> 方法为 <code>ture</code> 或者关联的所 有的 <code>Future</code> 都达到完成状态的时候，这个 <code>Stack</code> 才可以继续被调度执行。</p>
 </blockquote>
 <p>所以我们可以重载 <code>StackState</code> 的 <code>resumable</code> 方法！ 现在来重新定义一下我们 <code>PongTimeoutState</code></p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class PongTimeoutState extends StackState {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val pongFuture = MessageFuture[Pong]()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val timeoutFuture = MessageFuture[TimeoutReply]()
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>  override def resumable(): Boolean = timeoutFuture.isDone
</span><span line-number="6" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>现在只要 <code>timeoutFuture</code> 完成，那么 <code>Stack</code> 就可以重新执行了。不过当我们使用 <code>pongFuture</code> 时需要通过 <code>pongFuture.isDone</code> 检测其是否完成。这的确是一种方法，但是考虑到这是一种比较常见的需求，<code>otavia</code> 提供了更简单的方法，我们只需对最开始的 <code>PingActor</code> 进行一点点微小的改动：</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PingActor(pongActorAddress: Address[Ping]) extends StateActor[Start] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override def resumeNotice(stack: NoticeStack[Start]): Option[StackState] = stack.state match {
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case _: StartState =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>      println("PingActor handle Start message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>      println("PingActor send Ping Message")
</span><span line-number="6" class=""><span class="tooltip-container"></span>      val state = FutureState()
</span><span line-number="7" class=""><span class="tooltip-container"></span>      pongActorAddress.ask(Ping(stack.notice.sid), state.future, 2 * 1000)
</span><span line-number="8" class=""><span class="tooltip-container"></span>      stack.suspend(state)  
</span><span line-number="9" class=""><span class="tooltip-container"></span>    case state: FutureState[Pong] =&gt;
</span><span line-number="10" class=""><span class="tooltip-container"></span>      val future = state.future
</span><span line-number="11" class=""><span class="tooltip-container"></span>      if (future.isSuccess) {
</span><span line-number="12" class=""><span class="tooltip-container"></span>        println(s"PingActor received ${future.getNow} message success!")
</span><span line-number="13" class=""><span class="tooltip-container"></span>        assert(future.getNow.pingId == stack.ask.sid)
</span><span line-number="14" class=""><span class="tooltip-container"></span>      }
</span><span line-number="15" class=""><span class="tooltip-container"></span>      stack.`return`()
</span><span line-number="16" class=""><span class="tooltip-container"></span>  }
</span><span line-number="17" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>注意到不同的地方了吗！<code>ask</code> 方法自带了一个超时参数!</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>pongActorAddress.ask(Ping(stack.notice.sid), state.future, 2 * 1000) // new 
</span><span line-number="2" class=""><span class="tooltip-container"></span>pongActorAddress.ask(Ping(stack.notice.sid), state.future) // old
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>如果2秒后仍然没有收到 <code>Pong</code> 消息，那么这个 <code>Future</code> 将会被设置成完成状态，但是与之前不同的是我们不能从 <code>Future</code> 里面拿到 <code>Pong</code> 消息了，他的状态已经是失败了，即 <code>isDone=ture isSuccess=false isFailed=ture</code>。因为这个 <code>StackState</code> 只关联 了一个 <code>Future</code>，而这个 <code>Future</code> 已经是完成状态了，所以这个 <code>Stack</code> 就可以继续被调度执行了。</p>
</section>
<section id="actor-的生命周期-2">
 <h2 class="h500"><a href="#actor-的生命周期-2" class="anchor"></a>Actor 的生命周期</h2>
 <p>在 <code>otavia</code> 中，用户不用花太多心思管理 <code>Actor</code> 的生命周期，<code>Actor</code> 实例仍然被 JVM 垃圾回收管理。只要这个 <code>Actor</code> 不再被 GC 根对象引用，那么这个 <code>Actor</code> 实例将被 JVM 的垃圾回收系统自动回收。<code>Actor</code> 里有如下几种钩子方法可以在不同的生命周期过程中调用</p>
 <ul>
  <li><code>afterMount</code>: <code>Actor</code> 实例挂载到 <code>ActorSystem</code> 之后调用，**对于 Actor 实例 <code>context</code> 相关的方法只有挂载之后才可以使用 **。</li>
  <li><code>beforeRestart</code>: 重启之前调用。</li>
  <li><code>restart</code>: 重启 <code>Actor</code> 实例的方法。</li>
  <li><code>afterRestart</code>: 重启之后调用。</li>
  <li><code>AutoCleanable.cleaner</code>: 如果您实现的 <code>Actor</code> 需要清理一些不安全的资源，继承 <code>AutoCleanable</code> trait 然后实现 <code>cleaner</code> 方法。</li>
 </ul>
 <p>以下图片显示了 <code>Actor</code> 实例的生命周期：</p>
 <p><img src="../../images/actor_life_cycle.drawio.svg" alt=""></p>
 <p>我们来定义一个 <code>Actor</code> 看看生命周期中的各种钩子方法吧：</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Start() extends Notice
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>final class LifeActor extends StateActor[Start] with AutoCleanable {
</span><span line-number="4" class=""><span class="tooltip-container"></span>  override protected def afterMount(): Unit = println("LifeActor: afterMount")
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  override protected def beforeRestart(): Unit = println("LifeActor: beforeRestart")
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>  override protected def restart(): Unit = println("LifeActor: restart")
</span><span line-number="9" class=""><span class="tooltip-container"></span>
</span><span line-number="10" class=""><span class="tooltip-container"></span>  override protected def afterRestart(): Unit = println("LifeActor: afterRestart")
</span><span line-number="11" class=""><span class="tooltip-container"></span>
</span><span line-number="12" class=""><span class="tooltip-container"></span>  override def cleaner(): ActorCleaner = new ActorCleaner {
</span><span line-number="13" class=""><span class="tooltip-container"></span>
</span><span line-number="14" class=""><span class="tooltip-container"></span>    println("creating actor cleaner")
</span><span line-number="15" class=""><span class="tooltip-container"></span>
</span><span line-number="16" class=""><span class="tooltip-container"></span>    override protected def clean(): Unit = println("clean actor resource before actor stop")
</span><span line-number="17" class=""><span class="tooltip-container"></span>
</span><span line-number="18" class=""><span class="tooltip-container"></span>  }
</span><span line-number="19" class=""><span class="tooltip-container"></span>
</span><span line-number="20" class=""><span class="tooltip-container"></span>  // if occurs some error which developer is not catch, this will trigger the actor restart
</span><span line-number="21" class=""><span class="tooltip-container"></span>  // you can also override the noticeExceptionStrategy method to change the strategy
</span><span line-number="22" class=""><span class="tooltip-container"></span>  override def resumeNotice(stack: NoticeStack[Start]): Option[StackState] = {
</span><span line-number="23" class=""><span class="tooltip-container"></span>    println("process message")
</span><span line-number="24" class=""><span class="tooltip-container"></span>    throw new Error("")
</span><span line-number="25" class=""><span class="tooltip-container"></span>  }
</span><span line-number="26" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>其中 <code>afterMount</code> 方法最主要用来进行依赖注入，关于依赖注入，后文会进行详细讲解。</p>
</section>
<section id="处理io-1">
 <h2 class="h500"><a href="#处理io-1" class="anchor"></a>处理IO</h2>
 <p>现在我们已经学会了 1)定义 <code>Actor</code> 2)定义消息 3)发送消息 4)接收消息处理消息 5)使用 <code>Timer</code> 触发超时。</p>
 <p>但是在真实的业务中，我们往往需要处理很多 IO 任务，而 IO 任务又时常阻塞我们的线程，这也是导致我们的程序性能底下的原因之一。与此同时， 一些新的技术比如 epoll 、io_uring 等蓬勃发展，这使得我们可以不阻塞地处理 IO 任务。 JVM 中也提供了 NIO 来支持网络 IO ，但是 想要使用好 NIO 并不容易，因为 JVM 提供的 <code>java.nio.ByteBuffer</code> 和 <code>java.nio.channels.Channel</code> 等 API 太底层。 目前在 JVM 里更常见的是使用 <a href="https://netty.io/">Netty</a> 来处理IO任务。</p>
 <p>感谢 Netty 为 JVM 领域提供的强大的 IO 编程工具！受 Netty 启发，<code>otavia</code> 中的 IO 模块基本从 <code>Netty</code> 移植而来！ 在 <code>otavia</code> 中处理 IO 任务跟在 Netty 中非常像，可以说基本保持了 API 的一致。这也极大的方便了 <code>otavia</code> 从广泛的 Netty 生态系统中吸收营养，移植各种网络协议的编解码代码。<a href="https://github.com/otavia-projects">查看 otavia 生态</a>。</p>
 <p><img src="../../images/two_types_actor.drawio.svg" alt=""></p>
 <p><code>otavia</code> 同样使用 <code>Channel</code> 代表一个 IO 对象，比如一个打开的文件、一个网络连接。但是在 <code>otavia</code> 中，<code>Channel</code> 必须运行 在 <code>ChannelsActor</code> 中。同样 <code>Channel</code> 中也包含了一个 <code>ChannelPipeline</code> 组件，其中有一个 <code>ChannelHandler</code> 队列。</p>
 <p><img src="../../images/pipeline.drawio.svg" alt=""></p>
 <p>为了更好的对各种不同 <code>Channel</code> 的管理，<code>otavia</code> 实现了几种不同种类的 <code>ChannelsActor</code>，他们分别是：</p>
 <ul>
  <li><code>AcceptorActor</code>: 管理监听TCP连接的 <code>Channel</code>，其需要实例化一组 <code>AcceptedWorkerActor</code>, 对于监听 <code>Channel</code> 接受的普通 <code>Channel</code>，会作为消息发送给其中一个 <code>AcceptedWorkerActor</code>, 并且由 <code>AcceptedWorkerActor</code> 对接受的 <code>Channel</code> 进行管理 和数据的处理。</li>
  <li><code>AcceptedWorkerActor</code>: <code>AcceptorActor</code> 的工作 <code>Actor</code>。</li>
  <li><code>SocketChannelsActor</code>: 管理 TCP 客户端 <code>Channel</code>。</li>
  <li><code>DatagramChannelsActor</code>: 管理 UDP <code>Channel</code>。</li>
 </ul>
 <p>您需要根据需求选择一种类型的 <code>ChannelsActor</code> 进行实现。现在，让我们从一个简单的文件读取的例子开始我们的旅程！</p>
</section>
<section id="文件io-1">
 <h3 class="h400"><a href="#文件io-1" class="anchor"></a>文件IO</h3>
 <p>Netty 只支持网络 IO，<code>otavia</code> 不仅支持网络而且还支持文件。现在我们要实现一个 <code>Actor</code>， 他接收一个读取文件请求，然后将文件以 <code>Seq[String]</code> 的方式返回。</p>
 <p>首先，让我们来定义这个 <code>Actor</code> 需要处理和返回的消息</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class LinesReply(lines: Seq[String]) extends Reply
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>case class ReadLines() extends Ask[LinesReply]
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>接下来我们来实现我们的 <code>Actor</code>，这个 <code>Actor</code> 有怎么样的行为呢？首先需要打开文件！这样我们就有了代表这个文件的 <code>Channel</code>, 然后我们将读文件的命令发送给这个 <code>Channel</code></p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class ReadLinesActor(file: File, charset: Charset = StandardCharsets.UTF_8)
</span><span line-number="2" class=""><span class="tooltip-container"></span>  extends ChannelsActor[ReadLines] {
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>  override protected def initFileChannel(channel: Channel): Unit = ???
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  override def resumeAsk(stack: AskStack[ReadLines]): Option[StackState] = {
</span><span line-number="7" class=""><span class="tooltip-container"></span>    stack.state match {
</span><span line-number="8" class=""><span class="tooltip-container"></span>      case StackState.start =&gt;
</span><span line-number="9" class=""><span class="tooltip-container"></span>        stack.suspend(openFile(file, Seq(StandardOpenOption.READ), attrs = Seq.empty))  
</span><span line-number="10" class=""><span class="tooltip-container"></span>      case openState: ChannelFutureState if openState.id == 0 =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>        val linesState = ChannelFutureState(1)
</span><span line-number="12" class=""><span class="tooltip-container"></span>        openState.future.channel.ask(FileReadPlan(-1, -1), linesState.future)
</span><span line-number="13" class=""><span class="tooltip-container"></span>        stack.suspend(linesState)  
</span><span line-number="14" class=""><span class="tooltip-container"></span>      case linesState: ChannelFutureState if linesState.id == 1 =&gt;
</span><span line-number="15" class=""><span class="tooltip-container"></span>        stack.`return`(LinesReply(linesState.future.getNow.asInstanceOf[Seq[String]]))
</span><span line-number="16" class=""><span class="tooltip-container"></span>    }
</span><span line-number="17" class=""><span class="tooltip-container"></span>  }
</span><span line-number="18" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>首先我们使用 <code>openFile</code> 打开文件并且返回一个 <code>StackState</code> 状态，文件打开完成的时候这个状态就达到可运 行状态。其个方法是 <code>ChannelsActor</code> 提供的一个快捷方法，我们可以查看源码，其实现为：</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>// source code from ChannelsActor
</span><span line-number="2" class=""><span class="tooltip-container"></span>final protected def openFile(path: Path, opts: Seq[OpenOption], attrs: Seq[FileAttribute[?]]): StackState = {
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val channel               = createFileChannelAndInit()
</span><span line-number="4" class=""><span class="tooltip-container"></span>  val state                 = ChannelFutureState()
</span><span line-number="5" class=""><span class="tooltip-container"></span>  val future: ChannelFuture = state.future
</span><span line-number="6" class=""><span class="tooltip-container"></span>  channel.open(path, opts, attrs, future)
</span><span line-number="7" class=""><span class="tooltip-container"></span>  state
</span><span line-number="8" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>没什么特别的，跟我们之前讲过的 <code>Stack</code> 的执行过程差不多，只不过这里的 <code>StackState</code> 是 <code>ChannelFutureState</code> , 关联的 <code>Future</code> 是 <code>ChannelFuture</code>, 然后使用 <code>channel.open</code> 将这个 <code>Future</code> 传给 <code>Channel</code>。<code>open</code> 不是阻塞的，调用后就会立即返回。如果 这个文件真的打开完成，那么 <code>Reactor</code> 就会向 <code>ChannelsActor</code> 发送一个 <code>ReactorEvent</code>, <code>ChannelsActor</code> 收到事件后会将 这个 <code>ChannelFuture</code> 设置成完成状态。然后判断与其关联的 <code>Stack</code> 是否可以重新执行。</p>
 <p>这里我们还看见了一个 <code>createFileChannelAndInit</code> 方法，从方法名称我们就可以猜测出这个方法创建了一个文件 <code>Channel</code>，并且还对 这个 <code>Channel</code> 进行了初始化。 这个方法会调用 <code>ChannelsActor.initFileChannel</code> 方法对 <code>Channel</code> 进行初始化。</p>
 <p>现在我们可以来实现我们的 <code>ReadLinesActor.initFileChannel</code> 了。我们可以看见我们在文件打开之后传入了一个 <code>FileReadPlan</code> 对象：</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>val linesState = ChannelFutureState(1)
</span><span line-number="2" class=""><span class="tooltip-container"></span>openState.future.channel.ask(FileReadPlan(-1, -1), linesState.future)
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>这个 <code>ask</code> 方法最终会将 <code>FileReadPlan</code> 通过 <code>Channel</code> 的 <code>write</code> 方法传入 <code>ChannelPipeline</code>。 <code>ChannelPipeline</code> 里面的 <code>ChannelHandler</code> 是我们自己实现的，这跟 Netty 基本一样。</p>
 <p>现在我们来实现我们的 <code>ChannelHandler</code> 吧。这个 <code>ChannelHandler</code> 需要实现哪些功能呢？首先我们要能处理 <code>write</code> inbound 事件， 其次，我们需要对 <code>channelRead</code> outbound 事件进行处理；然后读文件完成的时候我们要处理 <code>channelReadComplete</code> outbound 事件， 在 <code>channelReadComplete</code> 事件中，我们需要生成最终的结果消息返回给我们的 <code>ReadLinesActor</code>。</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class ReadLinesHandler(charset: Charset) extends ByteToMessageDecoder {
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  private val lines = ArrayBuffer.empty[String]
</span><span line-number="4" class=""><span class="tooltip-container"></span>  private var currentMsgId: Long = -1
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  override def write(ctx: ChannelHandlerContext, msg: AnyRef, msgId: Long): Unit = msg match {
</span><span line-number="7" class=""><span class="tooltip-container"></span>    case readPlan: FileReadPlan =&gt;
</span><span line-number="8" class=""><span class="tooltip-container"></span>      ctx.read(readPlan)
</span><span line-number="9" class=""><span class="tooltip-container"></span>      currentMsgId = msgId
</span><span line-number="10" class=""><span class="tooltip-container"></span>    case _ =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>      ctx.write(msg, msgId)
</span><span line-number="12" class=""><span class="tooltip-container"></span>  }
</span><span line-number="13" class=""><span class="tooltip-container"></span>
</span><span line-number="14" class=""><span class="tooltip-container"></span>  override protected def decode(ctx: ChannelHandlerContext, input: AdaptiveBuffer): Unit = {
</span><span line-number="15" class=""><span class="tooltip-container"></span>    var continue = true
</span><span line-number="16" class=""><span class="tooltip-container"></span>    while (continue) {
</span><span line-number="17" class=""><span class="tooltip-container"></span>      val length = input.bytesBefore('\n'.toByte) + 1
</span><span line-number="18" class=""><span class="tooltip-container"></span>      if (length &gt; 0) {
</span><span line-number="19" class=""><span class="tooltip-container"></span>        lines.addOne(input.readCharSequence(length, charset).toString)
</span><span line-number="20" class=""><span class="tooltip-container"></span>      } else continue = false
</span><span line-number="21" class=""><span class="tooltip-container"></span>    }
</span><span line-number="22" class=""><span class="tooltip-container"></span>  }
</span><span line-number="23" class=""><span class="tooltip-container"></span>
</span><span line-number="24" class=""><span class="tooltip-container"></span>  override def channelReadComplete(ctx: ChannelHandlerContext): Unit = {
</span><span line-number="25" class=""><span class="tooltip-container"></span>    val seq = lines.toSeq
</span><span line-number="26" class=""><span class="tooltip-container"></span>    lines.clear()
</span><span line-number="27" class=""><span class="tooltip-container"></span>    val msgId = currentMsgId
</span><span line-number="28" class=""><span class="tooltip-container"></span>    currentMsgId = -1
</span><span line-number="29" class=""><span class="tooltip-container"></span>    ctx.fireChannelRead(seq, msgId)
</span><span line-number="30" class=""><span class="tooltip-container"></span>  }
</span><span line-number="31" class=""><span class="tooltip-container"></span>
</span><span line-number="32" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>然后我们还需要将这个 <code>ReadLinesHandler</code> 添加到我们的 <code>Channel</code> 的 <code>ChannelPipeline</code> 中，还记得我们之前在 <code>ReadLinesActor</code> 中没有实现的 <code>initFileChannel</code> 方法么。现在我们可以完成这个方法了！</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>override protected def initFileChannel(channel: Channel): Unit =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  channel.pipeline.addFirst(new ReadLinesHandler(charset))
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>我们可以注意到我们实现的 <code>write</code> 方法有一个 <code>msgId</code> 参数，这是 <code>ask</code> 方法生成的 <code>Channel</code> 内唯一的消息编号，因为 <code>write</code> 方法是非阻塞的，其并不会等待底层的IO完成直接拿到结果，而是直接通过 <code>ChannelHandlerContext.read</code> 向 <code>Reactor</code> 提交一个读 数据的计划，这个读数据的具体IO工作在 <code>otavia</code> 中会由 <code>Reactor</code> 完成，读到的数据会以 <code>Event</code> 的方式发送给 <code>ChannelsActor</code>。 然后 <code>ChannelsActor</code> 会将 <code>Event</code> 分发给具体的 <code>Channel</code>， <code>Channel</code> 会通过 <code>channelRead</code> 以 outbound 方向在 <code>ChannelPipeline</code> 中传播。这里我们继承的是 <code>ByteToMessageDecoder</code> ，他的 <code>channelRead</code> 方法会调用 <code>decode</code> 方法， 这个方法主要用于将字节序列转换成我们需要的对象。当 <code>Reactor</code> 读取数据完成，也会向 <code>ChannelsActor</code> 发送 <code>Event</code>，相对应的， 这种事件将会转换成 <code>channelReadComplete</code> outbound 事件在 <code>ChannelPipeline</code> 传播。我们需要在我们的 <code>ReadLinesHandler</code> 重写 <code>channelReadComplete</code> 方法以生成最终的结果并继续将结果以 <code>channelRead</code> 继续向 outbound 方向传播。注意到了么，我们 <code>fireChannelRead</code> 的方法同时也有一个 <code>msgId</code> 参数，这个参数会让这个消息最终找到我们之前的 <code>ask</code> 方法里面的 <code>Future</code>。接下来故事又回到了我们的 <code>Actor</code> 的 <code>Stack</code> 调度。</p>
 <p>现在让我们启动我们的程序来读一个文本文件吧！</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>@main def start(): Unit = {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val system = ActorSystem()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val readLinesActor = system.buildActor(() =&gt; new ReadLinesActor("build.sc"))
</span><span line-number="4" class=""><span class="tooltip-container"></span>  system.buildActor(() =&gt; new MainActor(Array.empty) {
</span><span line-number="5" class=""><span class="tooltip-container"></span>    override def main0(stack: NoticeStack[MainActor.Args]): Option[StackState] = stack.state match {
</span><span line-number="6" class=""><span class="tooltip-container"></span>      case _: StartState =&gt;
</span><span line-number="7" class=""><span class="tooltip-container"></span>        val state = FutureState[LinesReply]()
</span><span line-number="8" class=""><span class="tooltip-container"></span>        readLinesActor.ask(ReadLines(), state.future)
</span><span line-number="9" class=""><span class="tooltip-container"></span>        stack.suspend(state)  
</span><span line-number="10" class=""><span class="tooltip-container"></span>      case state: FutureState[LinesReply] =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>        for (line &lt;- state.future.getNow.lines) print(line)
</span><span line-number="12" class=""><span class="tooltip-container"></span>        stack.`return`()
</span><span line-number="13" class=""><span class="tooltip-container"></span>    }
</span><span line-number="14" class=""><span class="tooltip-container"></span>  })
</span><span line-number="15" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>您可能会想这也太麻烦了，我直接用 java 的文件 API 几行代码就搞定了，你却写了那么多！因为凡是有收益就有所付出，这种付出的收益就是 这种文件 IO 是不会阻塞当前 <code>Actor</code> 的执行线程的！ <code>otavia</code> 具体的 IO 读写工作是由 <code>Reactor</code> 组件完成的，其默认的传输层实 现是基于 NIO。 因为传输层是使用 SPI 机制实现的，所以我们可以替换这个默认的 NIO 传输层，基于 epoll、kqueue、IOCP 甚至 io_uring 等技术实现一个更加高性能的传输层！而这对于上层的代码是不需要一点变更的，只要您按照 SPI 规范实现了这个传输层模块，引入 依赖，就会立即生效！而实现这个高效的传输层模块正是 <a href="https://github.com/otavia-projects">otavia 生态</a> 中 <a href="https://github.com/otavia-projects/native-transport">native-transport</a> 项目的目标！如果你感兴趣，热烈欢迎您的贡献！</p>
</section>
<section id="网络-io-1">
 <h3 class="h400"><a href="#网络-io-1" class="anchor"></a>网络 IO</h3>
 <p>现在我们来实现一个基于 TCP 网络的 echo server，这个服务可以使用 telnet 链接，在 telnet 里面发送数据，这个服务将数据原样 返回给 telnet。因为是 TCP 服务，我们使用 <code>AcceptedWorkerActor</code> 与 <code>AcceptorActor</code> 来实现。我们实现的类分别为 <code>EchoAcceptor</code> 和 <code>EchoWorker</code></p>
 <p>首先我们来实现 <code>EchoAcceptor</code>，这个 <code>Actor</code> 管理一个监听连接的 <code>Channel</code>，接受连接后生成新的 <code>Channel</code>，然后将这个新 <code>Channel</code> 发送给 <code>EchoWorker</code>。由 <code>EchoWorker</code> 负责具体的工作任务。</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class EchoAcceptor extends AcceptorActor[EchoWorker] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override protected def workerNumber: Int = 4
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>  override protected def workerFactory: AcceptorActor.WorkerFactory[EchoServerWorker] =
</span><span line-number="5" class=""><span class="tooltip-container"></span>    () =&gt; new EchoWorker()
</span><span line-number="6" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>在 <code>EchoAcceptor</code> 中我们定义了如何创建 <code>EchoWorker</code> 的 <code>workerFactory</code> 方法和创建多少个 <code>EchoWorker</code> 实例的 <code>workerNumber</code>方法。 <code>EchoAcceptor</code> 接收 <code>ChannelsActor.Bind</code> 请求，然后创建一个 <code>Channel</code> 并且绑定到一个端口上用于 监听网络连接。同时会创建 <code>workerNumber</code> 个 <code>EchoWorker</code> 实例用于分发接收的网络连接。 接下来我们定义我们的 <code>EchoWorker</code></p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class EchoWorker extends AcceptedWorkerActor[Nothing] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  override protected def initChannel(channel: Channel): Unit = ???
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>  override def resumeAsk(stack: AskStack[AcceptedChannel]): Option[StackState] =
</span><span line-number="6" class=""><span class="tooltip-container"></span>    handleAccepted(stack)
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>  override protected def afterAccepted(channel: ChannelAddress): Unit =
</span><span line-number="9" class=""><span class="tooltip-container"></span>    println(s"EchoWorker accepted ${channel}")
</span><span line-number="10" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>注意到 <code>initChannel</code> 方法了么？与之前文件处理中的 <code>initFileChannel</code> 类似，不过这个是用来初始化网络 <code>Channel</code> 的方法。 同样我们也需要定义我们的 <code>ChannelHandler</code> 然后通过这个方法将 <code>ChannelHandler</code> 加入到 <code>Channel</code> 的 <code>ChannelPipeline</code> 中。现在我们来实现我们的 <code>ChannelHandler</code></p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class EchoWorkerHandler extends ByteToMessageDecoder {
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  override protected def decode(ctx: ChannelHandlerContext, input: AdaptiveBuffer): Unit =
</span><span line-number="4" class=""><span class="tooltip-container"></span>    if (input.readableBytes &gt; 0) ctx.writeAndFlush(input)
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>现在我们有了 <code>EchoWorkerHandler</code>，然后添加到我们的 <code>ChannelPipeline</code> 吧</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>override protected def initChannel(channel: Channel): Unit =
</span><span line-number="2" class=""><span class="tooltip-container"></span>  channel.pipeline.addLast(new EchoWorkerHandler())
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>现在一切已经就绪了，开始启动我们的 echo server 吧！</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>@main def start(): Unit = {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val actorSystem = ActorSystem()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  actorSystem.buildActor(() =&gt; new MainActor() {
</span><span line-number="4" class=""><span class="tooltip-container"></span>    override def main0(stack: NoticeStack[MainActor.Args]): Option[StackState] = stack.state match {
</span><span line-number="5" class=""><span class="tooltip-container"></span>      case _: StartState =&gt;
</span><span line-number="6" class=""><span class="tooltip-container"></span>        val acceptor = system.buildActor(() =&gt; new EchoAcceptor())
</span><span line-number="7" class=""><span class="tooltip-container"></span>        val state = FutureState[BindReply]()
</span><span line-number="8" class=""><span class="tooltip-container"></span>        acceptor.ask(Bind(8080), state.future)
</span><span line-number="9" class=""><span class="tooltip-container"></span>        stack.suspend(state)  
</span><span line-number="10" class=""><span class="tooltip-container"></span>      case state: FutureState[BindReply] =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>        println("echo server bind port 8080 success")
</span><span line-number="12" class=""><span class="tooltip-container"></span>        stack.`return`()
</span><span line-number="13" class=""><span class="tooltip-container"></span>    }
</span><span line-number="14" class=""><span class="tooltip-container"></span>  })
</span><span line-number="15" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>快启动 telnet 连接 echo server 试一下吧！</p>
 <blockquote>
  <p>这个例子只是简单介绍了一下 Channel 的用法，并没有展示出 Channel 与 ChannelsActor 更加强大的交互方式。 您可以通过 <a href="core_concept.html#channel">核心概念与设计</a> 了解更多。</p>
 </blockquote>
</section>
<section id="全局actor与依赖注入-1">
 <h2 class="h500"><a href="#全局actor与依赖注入-1" class="anchor"></a>全局Actor与依赖注入</h2>
 <p>依赖注入是一种很有效的拆解代码耦合的思想，这种思想同样对于 <code>Actor</code> 模型来说也同样有用。试想一下，有时候我们的 <code>Actor</code> 能接收的消息类型是固定的，但是在不同场景中我们却有不同的实现。如果使用 <code>buildActor</code> 来构造这些 <code>Actor</code>，那么就产生了严重的 代码耦合。每当场景变动我们都需要修改这部分代码，这非常的不灵活。为了解决这种问题，<code>otavia</code> 将依赖注入的思想引入了进来。接下来 我们将使用一个简单的例子来演示 <code>otavia</code> 中依赖注入 <code>Actor</code> 的方法。</p>
 <p>假设我们的系统中需要依赖一种服务 <code>Actor</code>，我们知道其接收和返回的消息类型，但是不同场景中这种服务的具体实现有些差异。如下是我们的 服务的消息定义。</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Result1() extends Reply
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>case class Query1() extends Ask[Result1]
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>case class Result2() extends Reply
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>case class Query2() extends Ask[Result2]
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>然后我们可以定义一个 <code>trait</code> 来约束我们的服务 <code>Actor</code> 能接收的消息。这与面向对象中依赖注入使用接口定义服务类似，只是面向对象 中使用接口约束能调用的方法而 <code>otavia</code> 中使用接口约束能处理的消息！</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>trait QueryService extends Actor[Query1 | Query2]
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>有了这个 <code>QueryService</code> 接口之后，我们实现的具体服务 <code>Actor</code> 只需继承这个接口。</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class QueryServiceImpl() extends StateActor with QueryService {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override def resumeAsk(stack: AskStack[Query1 | Query2]): Option[StackState] = ??? // impl logic
</span><span line-number="3" class=""><span class="tooltip-container"></span>}
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>// 另一种场景的 QueryService
</span><span line-number="6" class=""><span class="tooltip-container"></span>final class QueryServiceCase2() extends SocketChannelsActor with QueryService {
</span><span line-number="7" class=""><span class="tooltip-container"></span>  override def resumeAsk(stack: AskStack[Query1 | Query2]): Option[StackState] = ??? // impl logic
</span><span line-number="8" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>对于依赖 <code>QueryService</code> 的 <code>Actor</code>，可以使用 <code>autowire</code> 方法在 <code>ActorSystem</code> 中查找 可用的 <code>QueryService</code> 的 <code>Address</code>。</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Start() extends Notice
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>final class TestActor extends StateActor[Start] {
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>  private var queryService: Address[MessageOf[QueryService]] = _
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>  override protected def afterMount(): Unit = queryService = autowire[QueryService]()
</span><span line-number="8" class=""><span class="tooltip-container"></span>
</span><span line-number="9" class=""><span class="tooltip-container"></span>  override def resumeNotice(stack: NoticeStack[Start]): Option[StackState] = stack.state match {
</span><span line-number="10" class=""><span class="tooltip-container"></span>    case StackState.start =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>      val state = FutureState[Result1]()
</span><span line-number="12" class=""><span class="tooltip-container"></span>      queryService.ask(Query1(), state.future)
</span><span line-number="13" class=""><span class="tooltip-container"></span>      stack.suspend(state)  
</span><span line-number="14" class=""><span class="tooltip-container"></span>    case state: FutureState[?] =&gt;
</span><span line-number="15" class=""><span class="tooltip-container"></span>      val pong = state.future.asInstanceOf[MessageFuture[Result1]].getNow
</span><span line-number="16" class=""><span class="tooltip-container"></span>      stack.`return`()
</span><span line-number="17" class=""><span class="tooltip-container"></span>  }
</span><span line-number="18" class=""><span class="tooltip-container"></span>}
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>现在即使我们替换 <code>QueryService</code> 的实现， 我们的 <code>TestActor</code> 也不用做任何更改！如何让 <code>autowire[QueryService]()</code> 找到具体 的实现 <code>Actor</code> 呢，只需要在实例化实现 <code>Actor</code> 的时候将其设置为全局 <code>Actor</code>。</p>
 <div class="snippet mono-small-block" scala-snippet="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>system.buildActor(() =&gt; new QueryServiceImpl(), global = true)
</span><span line-number="2" class=""><span class="tooltip-container"></span>// or if use the other one
</span><span line-number="3" class=""><span class="tooltip-container"></span>system.buildActor(() =&gt; new QueryServiceCase2(), global = true)
</span></code></pre>
  <div class="buttons"></div>
 </div>
</section>
<section id="批量处理消息-1">
 <h2 class="h500"><a href="#批量处理消息-1" class="anchor"></a>批量处理消息</h2>
 <p>对某些场景来说，能够批量化处理消息是一个很有用的技术。启动批量化很简单，您只需要重写您的 <code>Actor</code> 的 <code>batchable</code> 方法，将其 返回值改为 <code>true</code>， 然后重写 <code>batchNoticeFilter</code> 或者 <code>batchAskFilter</code> 方法用来选择进入批量调度的消息。</p>
 <p>具体代码您可以参考 <a href="https://github.com/otavia-projects/otavia/blob/main/log4a/src/cc/otavia/log4a/appender/ConsoleAppender.scala">这里</a></p>
</section></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#环境要求-1">环境要求</a></li><li><a href="#添加依赖-1">添加依赖</a></li><li><a href="#简单的-ping-pong-actors-1">简单的 Ping-Pong Actors</a><ul><li><a href="#定义消息-1">定义消息</a></li><li><a href="#实现-actor-1">实现 Actor</a></li><li><a href="#运行-actor-1">运行 Actor</a></li></ul></li><li><a href="#接收多种类型消息的-actor-1">接收多种类型消息的 Actor</a></li><li><a href="#计时-1">计时</a><ul><li><a href="#处理注册的定时事件-1">处理注册的定时事件</a></li><li><a href="#stack-sleep-3">Stack Sleep</a></li><li><a href="#给-reply-消息设置超时-1">给 Reply 消息设置超时</a></li></ul></li><li><a href="#actor-的生命周期-2">Actor 的生命周期</a></li><li><a href="#处理io-1">处理IO</a><ul><li><a href="#文件io-1">文件IO</a></li><li><a href="#网络-io-1">网络 IO</a></li></ul></li><li><a href="#全局actor与依赖注入-1">全局Actor与依赖注入</a></li><li><a href="#批量处理消息-1">批量处理消息</a></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/otavia-projects/otavia"><button class="icon-button gh"></button></a><div class="text">Copyright (c) 2022, Yan Kun/Otavia Project</div></div><div class="text-mobile">Copyright (c) 2022, Yan Kun/Otavia Project</div></div></div></div></body></html>